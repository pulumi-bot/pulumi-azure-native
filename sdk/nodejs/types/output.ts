// *** WARNING: this file was generated by the Pulumi SDK Generator. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export namespace cache {
    /**
     * Redis cache access keys.
     */
    export interface RedisAccessKeysResponse {
        /**
         * The current primary key that clients can use to authenticate with Redis cache.
         */
        primaryKey: string;
        /**
         * The current secondary key that clients can use to authenticate with Redis cache.
         */
        secondaryKey: string;
    }

    /**
     * Specifies a range of IP addresses permitted to connect to the cache
     */
    export interface RedisFirewallRulePropertiesResponse {
        /**
         * highest IP address included in the range
         */
        endIP: string;
        /**
         * lowest IP address included in the range
         */
        startIP: string;
    }

    /**
     * Properties of a linked server to be returned in get/put response
     */
    export interface RedisLinkedServerPropertiesResponse {
        /**
         * Fully qualified resourceId of the linked redis cache.
         */
        linkedRedisCacheId: string;
        /**
         * Location of the linked redis cache.
         */
        linkedRedisCacheLocation: string;
        /**
         * Terminal state of the link between primary and secondary redis cache.
         */
        provisioningState: string;
        /**
         * Role of the linked server.
         */
        serverRole: string;
    }

    /**
     * Linked server Id
     */
    export interface RedisLinkedServerResponse {
        /**
         * Linked server Id.
         */
        id: string;
    }

    /**
     * Properties of the redis cache.
     */
    export interface RedisPropertiesResponse {
        /**
         * The keys of the Redis cache - not set if this object is not the response to Create or Update redis cache
         */
        accessKeys: outputs.cache.RedisAccessKeysResponse;
        /**
         * Specifies whether the non-ssl Redis server port (6379) is enabled.
         */
        enableNonSslPort?: boolean;
        /**
         * Redis host name.
         */
        hostName: string;
        /**
         * List of the linked servers associated with the cache
         */
        linkedServers: outputs.cache.RedisLinkedServerResponse[];
        /**
         * Optional: requires clients to use a specified TLS version (or higher) to connect (e,g, '1.0', '1.1', '1.2')
         */
        minimumTlsVersion?: string;
        /**
         * Redis non-SSL port.
         */
        port: number;
        /**
         * Redis instance provisioning status.
         */
        provisioningState: string;
        /**
         * All Redis Settings. Few possible keys: rdb-backup-enabled,rdb-storage-connection-string,rdb-backup-frequency,maxmemory-delta,maxmemory-policy,notify-keyspace-events,maxmemory-samples,slowlog-log-slower-than,slowlog-max-len,list-max-ziplist-entries,list-max-ziplist-value,hash-max-ziplist-entries,hash-max-ziplist-value,set-max-intset-entries,zset-max-ziplist-entries,zset-max-ziplist-value etc.
         */
        redisConfiguration?: {[key: string]: string};
        /**
         * Redis version.
         */
        redisVersion: string;
        /**
         * The number of shards to be created on a Premium Cluster Cache.
         */
        shardCount?: number;
        /**
         * The SKU of the Redis cache to deploy.
         */
        sku: outputs.cache.SkuResponse;
        /**
         * Redis SSL port.
         */
        sslPort: number;
        /**
         * Static IP address. Required when deploying a Redis cache inside an existing Azure Virtual Network.
         */
        staticIP?: string;
        /**
         * The full resource ID of a subnet in a virtual network to deploy the Redis cache in. Example format: /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/Microsoft.{Network|ClassicNetwork}/VirtualNetworks/vnet1/subnets/subnet1
         */
        subnetId?: string;
        /**
         * A dictionary of tenant settings
         */
        tenantSettings?: {[key: string]: string};
    }

    /**
     * List of patch schedules for a Redis cache.
     */
    export interface ScheduleEntriesResponse {
        /**
         * List of patch schedules for a Redis cache.
         */
        scheduleEntries: outputs.cache.ScheduleEntryResponse[];
    }

    /**
     * Patch schedule entry for a Premium Redis Cache.
     */
    export interface ScheduleEntryResponse {
        /**
         * Day of the week when a cache can be patched.
         */
        dayOfWeek: string;
        /**
         * ISO8601 timespan specifying how much time cache patching can take. 
         */
        maintenanceWindow?: string;
        /**
         * Start hour after which cache patching can start.
         */
        startHourUtc: number;
    }

    /**
     * SKU parameters supplied to the create Redis operation.
     */
    export interface SkuResponse {
        /**
         * The size of the Redis cache to deploy. Valid values: for C (Basic/Standard) family (0, 1, 2, 3, 4, 5, 6), for P (Premium) family (1, 2, 3, 4).
         */
        capacity: number;
        /**
         * The SKU family to use. Valid values: (C, P). (C = Basic/Standard, P = Premium).
         */
        family: string;
        /**
         * The type of Redis cache to deploy. Valid values: (Basic, Standard, Premium)
         */
        name: string;
    }
}

export namespace cdn {
    /**
     * The JSON object that contains the properties of the custom domain to create.
     */
    export interface CustomDomainPropertiesResponse {
        /**
         * Provisioning status of Custom Https of the custom domain.
         */
        customHttpsProvisioningState: string;
        /**
         * Provisioning substate shows the progress of custom HTTPS enabling/disabling process step by step.
         */
        customHttpsProvisioningSubstate: string;
        /**
         * The host name of the custom domain. Must be a domain name.
         */
        hostName: string;
        /**
         * Provisioning status of the custom domain.
         */
        provisioningState: string;
        /**
         * Resource status of the custom domain.
         */
        resourceState: string;
        /**
         * Special validation or data may be required when delivering CDN to some regions due to local compliance reasons. E.g. ICP license number of a custom domain is required to deliver content in China.
         */
        validationData?: string;
    }

    /**
     * Properties of the origin group created on the CDN endpoint.
     */
    export interface DeepCreatedOriginGroupPropertiesResponse {
        /**
         * Health probe settings to the origin that is used to determine the health of the origin.
         */
        healthProbeSettings?: outputs.cdn.HealthProbeParametersResponse;
        /**
         * The source of the content being delivered via CDN within given origin group.
         */
        origins: outputs.cdn.ResourceReferenceResponse[];
        /**
         * The JSON object that contains the properties to determine origin health using real requests/responses.This property is currently not supported.
         */
        responseBasedOriginErrorDetectionSettings?: outputs.cdn.ResponseBasedOriginErrorDetectionParametersResponse;
        /**
         * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
         */
        trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
    }

    /**
     * The origin group for CDN content which is added when creating a CDN endpoint. Traffic is sent to the origins within the origin group based on origin health.
     */
    export interface DeepCreatedOriginGroupResponse {
        /**
         * Origin group name which must be unique within the endpoint.
         */
        name: string;
        /**
         * Properties of the origin group created on the CDN endpoint.
         */
        properties?: outputs.cdn.DeepCreatedOriginGroupPropertiesResponse;
    }

    /**
     * Properties of the origin created on the CDN endpoint.
     */
    export interface DeepCreatedOriginPropertiesResponse {
        /**
         * Origin is enabled for load balancing or not. By default, origin is always enabled.
         */
        enabled?: boolean;
        /**
         * The address of the origin. It can be a domain name, IPv4 address, or IPv6 address. This should be unique across all origins in an endpoint.
         */
        hostName: string;
        /**
         * The value of the HTTP port. Must be between 1 and 65535.
         */
        httpPort?: number;
        /**
         * The value of the HTTPS port. Must be between 1 and 65535.
         */
        httpsPort?: number;
        /**
         * The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default. If endpoint uses multiple origins for load balancing, then the host header at endpoint is ignored and this one is considered.
         */
        originHostHeader?: string;
        /**
         * Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5.
         */
        priority?: number;
        /**
         * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
         */
        weight?: number;
    }

    /**
     * The main origin of CDN content which is added when creating a CDN endpoint.
     */
    export interface DeepCreatedOriginResponse {
        /**
         * Origin name which must be unique within the endpoint. 
         */
        name: string;
        /**
         * Properties of the origin created on the CDN endpoint.
         */
        properties?: outputs.cdn.DeepCreatedOriginPropertiesResponse;
    }

    /**
     * An action for the delivery rule.
     */
    export interface DeliveryRuleActionResponse {
        /**
         * The name of the action for the delivery rule.
         */
        name: string;
    }

    /**
     * A condition for the delivery rule.
     */
    export interface DeliveryRuleConditionResponse {
        /**
         * The name of the condition for the delivery rule.
         */
        name: string;
    }

    /**
     * A rule that specifies a set of actions and conditions
     */
    export interface DeliveryRuleResponse {
        /**
         * A list of actions that are executed when all the conditions of a rule are satisfied.
         */
        actions: outputs.cdn.DeliveryRuleActionResponse[];
        /**
         * A list of conditions that must be matched for the actions to be executed
         */
        conditions?: outputs.cdn.DeliveryRuleConditionResponse[];
        /**
         * Name of the rule
         */
        name?: string;
        /**
         * The order in which the rules are applied for the endpoint. Possible values {0,1,2,3,………}. A rule with a lesser order will be applied before a rule with a greater order. Rule with order 0 is a special rule. It does not require any condition and actions listed in it will always be applied.
         */
        order: number;
    }

    /**
     * The JSON object that contains the properties required to create an endpoint.
     */
    export interface EndpointPropertiesResponse {
        /**
         * List of content types on which compression applies. The value should be a valid MIME type.
         */
        contentTypesToCompress?: string[];
        /**
         * A reference to the origin group.
         */
        defaultOriginGroup?: outputs.cdn.ResourceReferenceResponse;
        /**
         * A policy that specifies the delivery rules to be used for an endpoint.
         */
        deliveryPolicy?: outputs.cdn.EndpointPropertiesUpdateParametersResponseProperties;
        /**
         * List of rules defining the user's geo access within a CDN endpoint. Each geo filter defines an access rule to a specified path or content, e.g. block APAC for path /pictures/
         */
        geoFilters?: outputs.cdn.GeoFilterResponse[];
        /**
         * The host name of the endpoint structured as {endpointName}.{DNSZone}, e.g. contoso.azureedge.net
         */
        hostName: string;
        /**
         * Indicates whether content compression is enabled on CDN. Default value is false. If compression is enabled, content will be served as compressed if user requests for a compressed version. Content won't be compressed on CDN when requested content is smaller than 1 byte or larger than 1 MB.
         */
        isCompressionEnabled?: boolean;
        /**
         * Indicates whether HTTP traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
         */
        isHttpAllowed?: boolean;
        /**
         * Indicates whether HTTPS traffic is allowed on the endpoint. Default value is true. At least one protocol (HTTP or HTTPS) must be allowed.
         */
        isHttpsAllowed?: boolean;
        /**
         * Specifies what scenario the customer wants this CDN endpoint to optimize for, e.g. Download, Media services. With this information, CDN can apply scenario driven optimization.
         */
        optimizationType?: string;
        /**
         * The origin groups comprising of origins that are used for load balancing the traffic based on availability.
         */
        originGroups?: outputs.cdn.DeepCreatedOriginGroupResponse[];
        /**
         * The host header value sent to the origin with each request. This property at Endpoint can only be set allowed when endpoint uses single origin. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default.
         */
        originHostHeader?: string;
        /**
         * A directory path on the origin that CDN can use to retrieve content from, e.g. contoso.cloudapp.net/originpath.
         */
        originPath?: string;
        /**
         * The source of the content being delivered via CDN.
         */
        origins: outputs.cdn.DeepCreatedOriginResponse[];
        /**
         * Path to a file hosted on the origin which helps accelerate delivery of the dynamic content and calculate the most optimal routes for the CDN. This is relative to the origin path. This property is only relevant when using a single origin.
         */
        probePath?: string;
        /**
         * Provisioning status of the endpoint.
         */
        provisioningState: string;
        /**
         * Defines how CDN caches requests that include query strings. You can ignore any query strings when caching, bypass caching to prevent requests that contain query strings from being cached, or cache every request with a unique URL.
         */
        queryStringCachingBehavior?: string;
        /**
         * Resource status of the endpoint.
         */
        resourceState: string;
    }

    /**
     * A policy that specifies the delivery rules to be used for an endpoint.
     */
    export interface EndpointPropertiesUpdateParametersResponseProperties {
        /**
         * User-friendly description of the policy.
         */
        description?: string;
        /**
         * A list of the delivery rules.
         */
        rules: outputs.cdn.DeliveryRuleResponse[];
    }

    /**
     * Rules defining user's geo access within a CDN endpoint.
     */
    export interface GeoFilterResponse {
        /**
         * Action of the geo filter, i.e. allow or block access.
         */
        action: string;
        /**
         * Two letter country codes defining user country access in a geo filter, e.g. AU, MX, US.
         */
        countryCodes: string[];
        /**
         * Relative path applicable to geo filter. (e.g. '/mypictures', '/mypicture/kitty.jpg', and etc.)
         */
        relativePath: string;
    }

    /**
     * The JSON object that contains the properties to send health probes to origin.
     */
    export interface HealthProbeParametersResponse {
        /**
         * The number of seconds between health probes.Default is 240sec.
         */
        probeIntervalInSeconds?: number;
        /**
         * The path relative to the origin that is used to determine the health of the origin.
         */
        probePath?: string;
        /**
         * Protocol to use for health probe.
         */
        probeProtocol?: string;
        /**
         * The type of health probe request that is made.
         */
        probeRequestType?: string;
    }

    /**
     * The JSON object that represents the range for http status codes
     */
    export interface HttpErrorRangeParametersResponse {
        /**
         * The inclusive start of the http status code range.
         */
        begin?: number;
        /**
         * The inclusive end of the http status code range.
         */
        end?: number;
    }

    /**
     * The JSON object that contains the properties of the origin group.
     */
    export interface OriginGroupPropertiesResponse {
        /**
         * Health probe settings to the origin that is used to determine the health of the origin.
         */
        healthProbeSettings?: outputs.cdn.HealthProbeParametersResponse;
        /**
         * The source of the content being delivered via CDN within given origin group.
         */
        origins: outputs.cdn.ResourceReferenceResponse[];
        /**
         * Provisioning status of the origin group.
         */
        provisioningState: string;
        /**
         * Resource status of the origin group.
         */
        resourceState: string;
        /**
         * The JSON object that contains the properties to determine origin health using real requests/responses. This property is currently not supported.
         */
        responseBasedOriginErrorDetectionSettings?: outputs.cdn.ResponseBasedOriginErrorDetectionParametersResponse;
        /**
         * Time in minutes to shift the traffic to the endpoint gradually when an unhealthy endpoint comes healthy or a new endpoint is added. Default is 10 mins. This property is currently not supported.
         */
        trafficRestorationTimeToHealedOrNewEndpointsInMinutes?: number;
    }

    /**
     * The JSON object that contains the properties of the origin.
     */
    export interface OriginPropertiesResponse {
        /**
         * Origin is enabled for load balancing or not
         */
        enabled?: boolean;
        /**
         * The address of the origin. Domain names, IPv4 addresses, and IPv6 addresses are supported.This should be unique across all origins in an endpoint.
         */
        hostName: string;
        /**
         * The value of the HTTP port. Must be between 1 and 65535.
         */
        httpPort?: number;
        /**
         * The value of the HTTPS port. Must be between 1 and 65535.
         */
        httpsPort?: number;
        /**
         * The host header value sent to the origin with each request. If you leave this blank, the request hostname determines this value. Azure CDN origins, such as Web Apps, Blob Storage, and Cloud Services require this host header value to match the origin hostname by default. If endpoint uses multiple origins for load balancing, then the host header at endpoint is ignored and this one is considered.
         */
        originHostHeader?: string;
        /**
         * Priority of origin in given origin group for load balancing. Higher priorities will not be used for load balancing if any lower priority origin is healthy.Must be between 1 and 5
         */
        priority?: number;
        /**
         * Provisioning status of the origin.
         */
        provisioningState: string;
        /**
         * Resource status of the origin.
         */
        resourceState: string;
        /**
         * Weight of the origin in given origin group for load balancing. Must be between 1 and 1000
         */
        weight?: number;
    }

    /**
     * The JSON object that contains the properties required to create a profile.
     */
    export interface ProfilePropertiesResponse {
        /**
         * Provisioning status of the profile.
         */
        provisioningState: string;
        /**
         * Resource status of the profile.
         */
        resourceState: string;
    }

    /**
     * Reference to another resource.
     */
    export interface ResourceReferenceResponse {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * The JSON object that contains the properties to determine origin health using real requests/responses.
     */
    export interface ResponseBasedOriginErrorDetectionParametersResponse {
        /**
         * The list of Http status code ranges that are considered as server errors for origin and it is marked as unhealthy.
         */
        httpErrorRanges?: outputs.cdn.HttpErrorRangeParametersResponse[];
        /**
         * Type of response errors for real user requests for which origin will be deemed unhealthy
         */
        responseBasedDetectedErrorTypes?: string;
        /**
         * The percentage of failed requests in the sample where failover should trigger.
         */
        responseBasedFailoverThresholdPercentage?: number;
    }

    /**
     * The pricing tier (defines a CDN provider, feature list and rate) of the CDN profile.
     */
    export interface SkuResponse {
        /**
         * Name of the pricing tier.
         */
        name?: string;
    }
}

export namespace compute {
    /**
     * Enables or disables a capability on the virtual machine or virtual machine scale set.
     */
    export interface AdditionalCapabilitiesResponse {
        /**
         * The flag that enables or disables a capability to have one or more managed data disks with UltraSSD_LRS storage account type on the VM or VMSS. Managed disks with storage account type UltraSSD_LRS can be added to a virtual machine or virtual machine scale set only if this property is enabled.
         */
        ultraSSDEnabled?: boolean;
    }

    /**
     * Specifies additional XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup. Contents are defined by setting name, component name, and the pass in which the content is applied.
     */
    export interface AdditionalUnattendContentResponse {
        /**
         * The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
         */
        componentName?: string;
        /**
         * Specifies the XML formatted content that is added to the unattend.xml file for the specified path and component. The XML must be less than 4KB and must include the root element for the setting or feature that is being inserted.
         */
        content?: string;
        /**
         * The pass name. Currently, the only allowable value is OobeSystem.
         */
        passName?: string;
        /**
         * Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
         */
        settingName?: string;
    }

    /**
     * The API entity reference.
     */
    export interface ApiEntityReferenceResponse {
        /**
         * The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
         */
        id?: string;
    }

    /**
     * The configuration parameters used for performing automatic OS upgrade.
     */
    export interface AutomaticOSUpgradePolicyResponse {
        /**
         * Whether OS image rollback feature should be disabled. Default value is false.
         */
        disableAutomaticRollback?: boolean;
        /**
         * Indicates whether OS upgrades should automatically be applied to scale set instances in a rolling fashion when a newer version of the OS image becomes available. Default value is false. If this is set to true for Windows based scale sets, recommendation is to set [enableAutomaticUpdates](https://docs.microsoft.com/dotnet/api/microsoft.azure.management.compute.models.windowsconfiguration.enableautomaticupdates?view=azure-dotnet) to false.
         */
        enableAutomaticOSUpgrade?: boolean;
    }

    /**
     * Specifies the configuration parameters for automatic repairs on the virtual machine scale set.
     */
    export interface AutomaticRepairsPolicyResponse {
        /**
         * Specifies whether automatic repairs should be enabled on the virtual machine scale set. The default value is false.
         */
        enabled?: boolean;
        /**
         * The amount of time for which automatic repairs are suspended due to a state change on VM. The grace time starts after the state change has completed. This helps avoid premature or accidental repairs. The time duration should be specified in ISO 8601 format. The minimum allowed grace period is 30 minutes (PT30M), which is also the default value. The maximum allowed grace period is 90 minutes (PT90M).
         */
        gracePeriod?: string;
    }

    /**
     * The instance view of a resource.
     */
    export interface AvailabilitySetPropertiesResponse {
        /**
         * Fault Domain count.
         */
        platformFaultDomainCount?: number;
        /**
         * Update Domain count.
         */
        platformUpdateDomainCount?: number;
        /**
         * Specifies information about the proximity placement group that the availability set should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * The resource status information.
         */
        statuses: outputs.compute.InstanceViewStatusResponse[];
        /**
         * A list of references to all virtual machines in the availability set.
         */
        virtualMachines?: outputs.compute.SubResourceResponse[];
    }

    /**
     * The instance view of a virtual machine boot diagnostics.
     */
    export interface BootDiagnosticsInstanceViewResponse {
        /**
         * The console screenshot blob URI.
         */
        consoleScreenshotBlobUri: string;
        /**
         * The Linux serial console log blob Uri.
         */
        serialConsoleLogBlobUri: string;
        /**
         * The boot diagnostics status information for the VM. <br><br> NOTE: It will be set only if there are errors encountered in enabling boot diagnostics.
         */
        status: outputs.compute.InstanceViewStatusResponse;
    }

    /**
     * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
     */
    export interface BootDiagnosticsResponse {
        /**
         * Whether boot diagnostics should be enabled on the Virtual Machine.
         */
        enabled?: boolean;
        /**
         * Uri of the storage account to use for placing the console output and screenshot.
         */
        storageUri?: string;
    }

    /**
     * Describes a data disk.
     */
    export interface DataDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.ManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * The virtual hard disk.
         */
        vhd?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
     */
    export interface DiagnosticsProfileResponse {
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsResponse;
    }

    /**
     * Describes the parameters of ephemeral disk settings that can be specified for operating system disk. <br><br> NOTE: The ephemeral disk settings can only be specified for managed disk.
     */
    export interface DiffDiskSettingsResponse {
        /**
         * Specifies the ephemeral disk settings for operating system disk.
         */
        option?: string;
    }

    /**
     * Describes a Encryption Settings for a Disk
     */
    export interface DiskEncryptionSettingsResponse {
        /**
         * Specifies the location of the disk encryption key, which is a Key Vault Secret.
         */
        diskEncryptionKey?: outputs.compute.KeyVaultSecretReferenceResponse;
        /**
         * Specifies whether disk encryption should be enabled on the virtual machine.
         */
        enabled?: boolean;
        /**
         * Specifies the location of the key encryption key in Key Vault.
         */
        keyEncryptionKey?: outputs.compute.KeyVaultKeyReferenceResponse;
    }

    /**
     * The instance view of the disk.
     */
    export interface DiskInstanceViewResponse {
        /**
         * Specifies the encryption settings for the OS Disk. <br><br> Minimum api-version: 2015-06-15
         */
        encryptionSettings?: outputs.compute.DiskEncryptionSettingsResponse[];
        /**
         * The disk name.
         */
        name?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
    }

    /**
     * Specifies the hardware settings for the virtual machine.
     */
    export interface HardwareProfileResponse {
        /**
         * Specifies the size of the virtual machine. For more information about virtual machine sizes, see [Sizes for virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-sizes?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> The available VM sizes depend on region and availability set. For a list of available sizes use these APIs:  <br><br> [List all available virtual machine sizes in an availability set](https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes) <br><br> [List all available virtual machine sizes in a region](https://docs.microsoft.com/rest/api/compute/virtualmachinesizes/list) <br><br> [List all available virtual machine sizes for resizing](https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes)
         */
        vmSize?: string;
    }

    /**
     * Describes a data disk.
     */
    export interface ImageDataDiskResponse {
        /**
         * The Virtual Hard Disk.
         */
        blobUri?: string;
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managedDisk.
         */
        managedDisk?: outputs.compute.SubResourceResponse;
        /**
         * The snapshot.
         */
        snapshot?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes an Operating System disk.
     */
    export interface ImageOSDiskResponse {
        /**
         * The Virtual Hard Disk.
         */
        blobUri?: string;
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies the size of empty data disks in gigabytes. This element can be used to overwrite the name of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * The managedDisk.
         */
        managedDisk?: outputs.compute.SubResourceResponse;
        /**
         * The OS State.
         */
        osState: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from a custom image. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType: string;
        /**
         * The snapshot.
         */
        snapshot?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage account type for the managed disk. UltraSSD_LRS cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes the properties of an Image.
     */
    export interface ImagePropertiesResponse {
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * The source virtual machine from which Image is created.
         */
        sourceVirtualMachine?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.ImageStorageProfileResponse;
    }

    /**
     * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations. NOTE: Image reference publisher and offer can only be set when you create the scale set.
     */
    export interface ImageReferenceResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Specifies the offer of the platform image or marketplace image used to create the virtual machine.
         */
        offer?: string;
        /**
         * The image publisher.
         */
        publisher?: string;
        /**
         * The image SKU.
         */
        sku?: string;
        /**
         * Specifies the version of the platform image or marketplace image used to create the virtual machine. The allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically update after deploy time even if a new version becomes available.
         */
        version?: string;
    }

    /**
     * Describes a storage profile.
     */
    export interface ImageStorageProfileResponse {
        /**
         * Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.ImageDataDiskResponse[];
        /**
         * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.ImageOSDiskResponse;
        /**
         * Specifies whether an image is zone resilient or not. Default is false. Zone resilient images can be created only in regions that provide Zone Redundant Storage (ZRS).
         */
        zoneResilient?: boolean;
    }

    /**
     * Instance view status.
     */
    export interface InstanceViewStatusResponse {
        /**
         * The status code.
         */
        code?: string;
        /**
         * The short localizable label for the status.
         */
        displayStatus?: string;
        /**
         * The level code.
         */
        level?: string;
        /**
         * The detailed status message, including for alerts and error messages.
         */
        message?: string;
        /**
         * The time of the status.
         */
        time?: string;
    }

    /**
     * Describes a reference to Key Vault Key
     */
    export interface KeyVaultKeyReferenceResponse {
        /**
         * The URL referencing a key encryption key in Key Vault.
         */
        keyUrl: string;
        /**
         * The relative URL of the Key Vault containing the key.
         */
        sourceVault: outputs.compute.SubResourceResponse;
    }

    /**
     * Describes a reference to Key Vault Secret
     */
    export interface KeyVaultSecretReferenceResponse {
        /**
         * The URL referencing a secret in a Key Vault.
         */
        secretUrl: string;
        /**
         * The relative URL of the Key Vault containing the secret.
         */
        sourceVault: outputs.compute.SubResourceResponse;
    }

    /**
     * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
     */
    export interface LinuxConfigurationResponse {
        /**
         * Specifies whether password authentication should be disabled.
         */
        disablePasswordAuthentication?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
         */
        provisionVMAgent?: boolean;
        /**
         * Specifies the ssh key configuration for a Linux OS.
         */
        ssh?: outputs.compute.SshConfigurationResponse;
    }

    /**
     * Maintenance Operation Status.
     */
    export interface MaintenanceRedeployStatusResponse {
        /**
         * True, if customer is allowed to perform Maintenance.
         */
        isCustomerInitiatedMaintenanceAllowed?: boolean;
        /**
         * Message returned for the last Maintenance Operation.
         */
        lastOperationMessage?: string;
        /**
         * The Last Maintenance Operation Result Code.
         */
        lastOperationResultCode?: string;
        /**
         * End Time for the Maintenance Window.
         */
        maintenanceWindowEndTime?: string;
        /**
         * Start Time for the Maintenance Window.
         */
        maintenanceWindowStartTime?: string;
        /**
         * End Time for the Pre Maintenance Window.
         */
        preMaintenanceWindowEndTime?: string;
        /**
         * Start Time for the Pre Maintenance Window.
         */
        preMaintenanceWindowStartTime?: string;
    }

    /**
     * The parameters of a managed disk.
     */
    export interface ManagedDiskParametersResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes a network interface reference properties.
     */
    export interface NetworkInterfaceReferencePropertiesResponse {
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
    }

    /**
     * Describes a network interface reference.
     */
    export interface NetworkInterfaceReferenceResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * Describes a network interface reference properties.
         */
        properties?: outputs.compute.NetworkInterfaceReferencePropertiesResponse;
    }

    /**
     * Specifies the network interfaces of the virtual machine.
     */
    export interface NetworkProfileResponse {
        /**
         * Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
         */
        networkInterfaces?: outputs.compute.NetworkInterfaceReferenceResponse[];
    }

    /**
     * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
     */
    export interface OSDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies how the virtual machine should be created.<br><br> Possible values are:<br><br> **Attach** \u2013 This value is used when you are using a specialized disk to create the virtual machine.<br><br> **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
         */
        diffDiskSettings?: outputs.compute.DiffDiskSettingsResponse;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the encryption settings for the OS Disk. <br><br> Minimum api-version: 2015-06-15
         */
        encryptionSettings?: outputs.compute.DiskEncryptionSettingsResponse;
        /**
         * The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine. If SourceImage is provided, the destination virtual hard drive must not exist.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.ManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType?: string;
        /**
         * The virtual hard disk.
         */
        vhd?: outputs.compute.VirtualHardDiskResponse;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Specifies the operating system settings for the virtual machine.
     */
    export interface OSProfileResponse {
        /**
         * Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
         */
        adminPassword?: string;
        /**
         * Specifies the name of the administrator account. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        adminUsername?: string;
        /**
         * Specifies whether extension operations should be allowed on the virtual machine. <br><br>This may only be set to False when no extensions are present on the virtual machine.
         */
        allowExtensionOperations?: boolean;
        /**
         * Specifies the host OS name of the virtual machine. <br><br> This name cannot be updated after the VM is created. <br><br> **Max-length (Windows):** 15 characters <br><br> **Max-length (Linux):** 64 characters. <br><br> For naming conventions and restrictions see [Azure infrastructure services implementation guidelines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-infrastructure-subscription-accounts-guidelines?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#1-naming-conventions).
         */
        computerName?: string;
        /**
         * Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        customData?: string;
        /**
         * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        linuxConfiguration?: outputs.compute.LinuxConfigurationResponse;
        /**
         * Specifies set of certificates that should be installed onto the virtual machine.
         */
        secrets?: outputs.compute.VaultSecretGroupResponse[];
        /**
         * Specifies Windows operating system settings on the virtual machine.
         */
        windowsConfiguration?: outputs.compute.WindowsConfigurationResponse;
    }

    /**
     * Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace images. Before you can use a marketplace image from an API, you must enable the image for programmatic use.  In the Azure portal, find the marketplace image that you want to use and then click **Want to deploy programmatically, Get Started ->**. Enter any required information and then click **Save**.
     */
    export interface PlanResponse {
        /**
         * The plan ID.
         */
        name?: string;
        /**
         * Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
         */
        product?: string;
        /**
         * The promotion code.
         */
        promotionCode?: string;
        /**
         * The publisher ID.
         */
        publisher?: string;
    }

    /**
     * Describes the properties of a Proximity Placement Group.
     */
    export interface ProximityPlacementGroupPropertiesResponse {
        /**
         * A list of references to all availability sets in the proximity placement group.
         */
        availabilitySets: outputs.compute.SubResourceResponse[];
        /**
         * Specifies the type of the proximity placement group. <br><br> Possible values are: <br><br> **Standard** : Co-locate resources within an Azure region or Availability Zone. <br><br> **Ultra** : For future use.
         */
        proximityPlacementGroupType?: string;
        /**
         * A list of references to all virtual machine scale sets in the proximity placement group.
         */
        virtualMachineScaleSets: outputs.compute.SubResourceResponse[];
        /**
         * A list of references to all virtual machines in the proximity placement group.
         */
        virtualMachines: outputs.compute.SubResourceResponse[];
    }

    /**
     * The configuration parameters used while performing a rolling upgrade.
     */
    export interface RollingUpgradePolicyResponse {
        /**
         * The maximum percent of total virtual machine instances that will be upgraded simultaneously by the rolling upgrade in one batch. As this is a maximum, unhealthy instances in previous or future batches can cause the percentage of instances in a batch to decrease to ensure higher reliability. The default value for this parameter is 20%.
         */
        maxBatchInstancePercent?: number;
        /**
         * The maximum percentage of the total virtual machine instances in the scale set that can be simultaneously unhealthy, either as a result of being upgraded, or by being found in an unhealthy state by the virtual machine health checks before the rolling upgrade aborts. This constraint will be checked prior to starting any batch. The default value for this parameter is 20%.
         */
        maxUnhealthyInstancePercent?: number;
        /**
         * The maximum percentage of upgraded virtual machine instances that can be found to be in an unhealthy state. This check will happen after each batch is upgraded. If this percentage is ever exceeded, the rolling update aborts. The default value for this parameter is 20%.
         */
        maxUnhealthyUpgradedInstancePercent?: number;
        /**
         * The wait time between completing the update for all virtual machines in one batch and starting the next batch. The time duration should be specified in ISO 8601 format. The default value is 0 seconds (PT0S).
         */
        pauseTimeBetweenBatches?: string;
    }

    /**
     * Describes a virtual machine scale set sku. NOTE: If the new VM SKU is not supported on the hardware the scale set is currently on, you need to deallocate the VMs in the scale set before you modify the SKU name.
     */
    export interface SkuResponse {
        /**
         * Specifies the number of virtual machines in the scale set.
         */
        capacity?: number;
        /**
         * The sku name.
         */
        name?: string;
        /**
         * Specifies the tier of virtual machines in a scale set.<br /><br /> Possible Values:<br /><br /> **Standard**<br /><br /> **Basic**
         */
        tier?: string;
    }

    /**
     * SSH configuration for Linux based VMs running on Azure
     */
    export interface SshConfigurationResponse {
        /**
         * The list of SSH public keys used to authenticate with linux based VMs.
         */
        publicKeys?: outputs.compute.SshPublicKeyResponse[];
    }

    /**
     * Contains information about SSH certificate public key and the path on the Linux VM where the public key is placed.
     */
    export interface SshPublicKeyResponse {
        /**
         * SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        keyData?: string;
        /**
         * Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
         */
        path?: string;
    }

    /**
     * Specifies the storage settings for the virtual machine disks.
     */
    export interface StorageProfileResponse {
        /**
         * Specifies the parameters that are used to add a data disk to a virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.DataDiskResponse[];
        /**
         * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
         */
        imageReference?: outputs.compute.ImageReferenceResponse;
        /**
         * Specifies information about the operating system disk used by the virtual machine. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.OSDiskResponse;
    }

    export interface SubResourceResponse {
        /**
         * Resource Id
         */
        id?: string;
    }

    /**
     * Describes an upgrade policy - automatic, manual, or rolling.
     */
    export interface UpgradePolicyResponse {
        /**
         * Configuration parameters used for performing automatic OS Upgrade.
         */
        automaticOSUpgradePolicy?: outputs.compute.AutomaticOSUpgradePolicyResponse;
        /**
         * Specifies the mode of an upgrade to virtual machines in the scale set.<br /><br /> Possible values are:<br /><br /> **Manual** - You  control the application of updates to virtual machines in the scale set. You do this by using the manualUpgrade action.<br /><br /> **Automatic** - All virtual machines in the scale set are  automatically updated at the same time.
         */
        mode?: string;
        /**
         * The configuration parameters used while performing a rolling upgrade.
         */
        rollingUpgradePolicy?: outputs.compute.RollingUpgradePolicyResponse;
    }

    /**
     * Describes a single certificate reference in a Key Vault, and where the certificate should reside on the VM.
     */
    export interface VaultCertificateResponse {
        /**
         * For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified certificate store is implicitly in the LocalMachine account. <br><br>For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name &lt;UppercaseThumbprint&gt;.crt for the X509 certificate file and &lt;UppercaseThumbprint&gt;.prv for private key. Both of these files are .pem formatted.
         */
        certificateStore?: string;
        /**
         * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
         */
        certificateUrl?: string;
    }

    /**
     * Describes a set of certificates which are all in the same Key Vault.
     */
    export interface VaultSecretGroupResponse {
        /**
         * The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
         */
        sourceVault?: outputs.compute.SubResourceResponse;
        /**
         * The list of key vault references in SourceVault which contain certificates.
         */
        vaultCertificates?: outputs.compute.VaultCertificateResponse[];
    }

    /**
     * Describes the uri of a disk.
     */
    export interface VirtualHardDiskResponse {
        /**
         * Specifies the virtual hard disk's uri.
         */
        uri?: string;
    }

    /**
     * The instance view of the VM Agent running on the virtual machine.
     */
    export interface VirtualMachineAgentInstanceViewResponse {
        /**
         * The virtual machine extension handler instance view.
         */
        extensionHandlers?: outputs.compute.VirtualMachineExtensionHandlerInstanceViewResponse[];
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent full version.
         */
        vmAgentVersion?: string;
    }

    /**
     * The instance view of a virtual machine extension handler.
     */
    export interface VirtualMachineExtensionHandlerInstanceViewResponse {
        /**
         * The extension handler status.
         */
        status?: outputs.compute.InstanceViewStatusResponse;
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * The instance view of a virtual machine extension.
     */
    export interface VirtualMachineExtensionInstanceViewResponse {
        /**
         * The virtual machine extension name.
         */
        name?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The resource status information.
         */
        substatuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes the properties of a Virtual Machine Extension.
     */
    export interface VirtualMachineExtensionPropertiesResponse {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * How the extension handler should be forced to update even if the extension configuration has not changed.
         */
        forceUpdateTag?: string;
        /**
         * The virtual machine extension instance view.
         */
        instanceView?: outputs.compute.VirtualMachineExtensionInstanceViewResponse;
        /**
         * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
         */
        protectedSettings?: {[key: string]: string};
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The name of the extension handler publisher.
         */
        publisher?: string;
        /**
         * Json formatted public settings for the extension.
         */
        settings?: {[key: string]: string};
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes a Virtual Machine Extension.
     */
    export interface VirtualMachineExtensionResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * Resource location
         */
        location: string;
        /**
         * Resource name
         */
        name: string;
        /**
         * Describes the properties of a Virtual Machine Extension.
         */
        properties?: outputs.compute.VirtualMachineExtensionPropertiesResponse;
        /**
         * Resource tags
         */
        tags?: {[key: string]: string};
        /**
         * Resource type
         */
        type: string;
    }

    /**
     * The health status of the VM.
     */
    export interface VirtualMachineHealthStatusResponse {
        /**
         * The health status information for the VM.
         */
        status: outputs.compute.InstanceViewStatusResponse;
    }

    /**
     * Identity for the virtual machine.
     */
    export interface VirtualMachineIdentityResponse {
        /**
         * The principal id of virtual machine identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the virtual machine. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine.
         */
        type?: string;
        /**
         * The list of user identities associated with the Virtual Machine. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * The instance view of a virtual machine.
     */
    export interface VirtualMachineInstanceViewResponse {
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsInstanceViewResponse;
        /**
         * The computer name assigned to the virtual machine.
         */
        computerName?: string;
        /**
         * The virtual machine disk information.
         */
        disks?: outputs.compute.DiskInstanceViewResponse[];
        /**
         * The extensions information.
         */
        extensions?: outputs.compute.VirtualMachineExtensionInstanceViewResponse[];
        /**
         * The Maintenance Operation status on the virtual machine.
         */
        maintenanceRedeployStatus?: outputs.compute.MaintenanceRedeployStatusResponse;
        /**
         * The Operating System running on the virtual machine.
         */
        osName?: string;
        /**
         * The version of Operating System running on the virtual machine.
         */
        osVersion?: string;
        /**
         * Specifies the fault domain of the virtual machine.
         */
        platformFaultDomain?: number;
        /**
         * Specifies the update domain of the virtual machine.
         */
        platformUpdateDomain?: number;
        /**
         * The Remote desktop certificate thumbprint.
         */
        rdpThumbPrint?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent running on the virtual machine.
         */
        vmAgent?: outputs.compute.VirtualMachineAgentInstanceViewResponse;
    }

    /**
     * Describes the properties of a Virtual Machine.
     */
    export interface VirtualMachinePropertiesResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the virtual machine.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For more information about availability sets, see [Manage the availability of virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> For more information on Azure planned maintenance, see [Planned maintenance for virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Currently, a VM can only be added to availability set at creation time. An existing VM cannot be added to an availability set.
         */
        availabilitySet?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the hardware settings for the virtual machine.
         */
        hardwareProfile?: outputs.compute.HardwareProfileResponse;
        /**
         * The virtual machine instance view.
         */
        instanceView: outputs.compute.VirtualMachineInstanceViewResponse;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies the network interfaces of the virtual machine.
         */
        networkProfile?: outputs.compute.NetworkProfileResponse;
        /**
         * Specifies the operating system settings for the virtual machine.
         */
        osProfile?: outputs.compute.OSProfileResponse;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies information about the proximity placement group that the virtual machine should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.StorageProfileResponse;
        /**
         * Specifies the VM unique ID which is a 128-bits identifier that is encoded and stored in all Azure IaaS VMs SMBIOS and can be read using platform BIOS commands.
         */
        vmId: string;
    }

    /**
     * Describes a virtual machine scale set data disk.
     */
    export interface VirtualMachineScaleSetDataDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * The create option.
         */
        createOption: string;
        /**
         * Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and therefore must be unique for each data disk attached to a VM.
         */
        lun: number;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.VirtualMachineScaleSetManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Describes a virtual machine scale set extension profile.
     */
    export interface VirtualMachineScaleSetExtensionProfileResponse {
        /**
         * The virtual machine scale set child extension resources.
         */
        extensions?: outputs.compute.VirtualMachineScaleSetExtensionResponse[];
    }

    /**
     * Describes the properties of a Virtual Machine Scale Set Extension.
     */
    export interface VirtualMachineScaleSetExtensionPropertiesResponse {
        /**
         * Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed, however, the extension will not upgrade minor versions unless redeployed, even with this property set to true.
         */
        autoUpgradeMinorVersion?: boolean;
        /**
         * If a value is provided and is different from the previous value, the extension handler will be forced to update even if the extension configuration has not changed.
         */
        forceUpdateTag?: string;
        /**
         * The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
         */
        protectedSettings?: {[key: string]: string};
        /**
         * Collection of extension names after which this extension needs to be provisioned.
         */
        provisionAfterExtensions?: string[];
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * The name of the extension handler publisher.
         */
        publisher?: string;
        /**
         * Json formatted public settings for the extension.
         */
        settings?: {[key: string]: string};
        /**
         * Specifies the type of the extension; an example is "CustomScriptExtension".
         */
        type?: string;
        /**
         * Specifies the version of the script handler.
         */
        typeHandlerVersion?: string;
    }

    /**
     * Describes a Virtual Machine Scale Set Extension.
     */
    export interface VirtualMachineScaleSetExtensionResponse {
        /**
         * Resource Id
         */
        id: string;
        /**
         * The name of the extension.
         */
        name?: string;
        /**
         * Describes the properties of a Virtual Machine Scale Set Extension.
         */
        properties?: outputs.compute.VirtualMachineScaleSetExtensionPropertiesResponse;
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration properties.
     */
    export interface VirtualMachineScaleSetIPConfigurationPropertiesResponse {
        /**
         * Specifies an array of references to backend address pools of application gateways. A scale set can reference backend address pools of multiple application gateways. Multiple scale sets cannot use the same application gateway.
         */
        applicationGatewayBackendAddressPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to application security group.
         */
        applicationSecurityGroups?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to backend address pools of load balancers. A scale set can reference backend address pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer.
         */
        loadBalancerBackendAddressPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies an array of references to inbound Nat pools of the load balancers. A scale set can reference inbound nat pools of one public and one internal load balancer. Multiple scale sets cannot use the same load balancer
         */
        loadBalancerInboundNatPools?: outputs.compute.SubResourceResponse[];
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
        /**
         * Available from Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
         */
        privateIPAddressVersion?: string;
        /**
         * The publicIPAddressConfiguration.
         */
        publicIPAddressConfiguration?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationResponse;
        /**
         * Specifies the identifier of the subnet.
         */
        subnet?: outputs.compute.ApiEntityReferenceResponse;
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration.
     */
    export interface VirtualMachineScaleSetIPConfigurationResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * The IP configuration name.
         */
        name: string;
        /**
         * Describes a virtual machine scale set network profile's IP configuration properties.
         */
        properties?: outputs.compute.VirtualMachineScaleSetIPConfigurationPropertiesResponse;
    }

    /**
     * Identity for the virtual machine scale set.
     */
    export interface VirtualMachineScaleSetIdentityResponse {
        /**
         * The principal id of virtual machine scale set identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the virtual machine scale set. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the virtual machine scale set. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the virtual machine scale set.
         */
        type?: string;
        /**
         * The list of user identities associated with the virtual machine scale set. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Contains the IP tag associated with the public IP address.
     */
    export interface VirtualMachineScaleSetIpTagResponse {
        /**
         * IP tag type. Example: FirstPartyUsage.
         */
        ipTagType?: string;
        /**
         * IP tag associated with the public IP. Example: SQL, Storage etc.
         */
        tag?: string;
    }

    /**
     * Describes the parameters of a ScaleSet managed disk.
     */
    export interface VirtualMachineScaleSetManagedDiskParametersResponse {
        /**
         * Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot be used with OS Disk.
         */
        storageAccountType?: string;
    }

    /**
     * Describes a virtual machines scale sets network configuration's DNS settings.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationDnsSettingsResponse {
        /**
         * List of DNS servers IP addresses
         */
        dnsServers?: string[];
    }

    /**
     * Describes a virtual machine scale set network profile's IP configuration.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationPropertiesResponse {
        /**
         * The dns settings to be applied on the network interfaces.
         */
        dnsSettings?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationDnsSettingsResponse;
        /**
         * Specifies whether the network interface is accelerated networking-enabled.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Whether IP forwarding enabled on this NIC.
         */
        enableIPForwarding?: boolean;
        /**
         * Specifies the IP configurations of the network interface.
         */
        ipConfigurations: outputs.compute.VirtualMachineScaleSetIPConfigurationResponse[];
        /**
         * The network security group.
         */
        networkSecurityGroup?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the primary network interface in case the virtual machine has more than 1 network interface.
         */
        primary?: boolean;
    }

    /**
     * Describes a virtual machine scale set network profile's network configurations.
     */
    export interface VirtualMachineScaleSetNetworkConfigurationResponse {
        /**
         * Resource Id
         */
        id?: string;
        /**
         * The network configuration name.
         */
        name: string;
        /**
         * Describes a virtual machine scale set network profile's IP configuration.
         */
        properties?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationPropertiesResponse;
    }

    /**
     * Describes a virtual machine scale set network profile.
     */
    export interface VirtualMachineScaleSetNetworkProfileResponse {
        /**
         * A reference to a load balancer probe used to determine the health of an instance in the virtual machine scale set. The reference will be in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/loadBalancers/{loadBalancerName}/probes/{probeName}'.
         */
        healthProbe?: outputs.compute.ApiEntityReferenceResponse;
        /**
         * The list of network configurations.
         */
        networkInterfaceConfigurations?: outputs.compute.VirtualMachineScaleSetNetworkConfigurationResponse[];
    }

    /**
     * Describes a virtual machine scale set operating system disk.
     */
    export interface VirtualMachineScaleSetOSDiskResponse {
        /**
         * Specifies the caching requirements. <br><br> Possible values are: <br><br> **None** <br><br> **ReadOnly** <br><br> **ReadWrite** <br><br> Default: **None for Standard storage. ReadOnly for Premium storage**
         */
        caching?: string;
        /**
         * Specifies how the virtual machines in the scale set should be created.<br><br> The only allowed value is: **FromImage** \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform image, you also use the imageReference element described above. If you are using a marketplace image, you  also use the plan element previously described.
         */
        createOption: string;
        /**
         * Specifies the ephemeral disk Settings for the operating system disk used by the virtual machine scale set.
         */
        diffDiskSettings?: outputs.compute.DiffDiskSettingsResponse;
        /**
         * Specifies the size of the operating system disk in gigabytes. This element can be used to overwrite the size of the disk in a virtual machine image. <br><br> This value cannot be larger than 1023 GB
         */
        diskSizeGB?: number;
        /**
         * Specifies information about the unmanaged user image to base the scale set on.
         */
        image?: outputs.compute.VirtualHardDiskResponse;
        /**
         * The managed disk parameters.
         */
        managedDisk?: outputs.compute.VirtualMachineScaleSetManagedDiskParametersResponse;
        /**
         * The disk name.
         */
        name?: string;
        /**
         * This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or a specialized VHD. <br><br> Possible values are: <br><br> **Windows** <br><br> **Linux**
         */
        osType?: string;
        /**
         * Specifies the container urls that are used to store operating system disks for the scale set.
         */
        vhdContainers?: string[];
        /**
         * Specifies whether writeAccelerator should be enabled or disabled on the disk.
         */
        writeAcceleratorEnabled?: boolean;
    }

    /**
     * Describes a virtual machine scale set OS profile.
     */
    export interface VirtualMachineScaleSetOSProfileResponse {
        /**
         * Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-reset-rdp?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-vmaccess-extension?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json#reset-root-password)
         */
        adminPassword?: string;
        /**
         * Specifies the name of the administrator account. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters  <br><br><li> For root access to the Linux VM, see [Using root privileges on Linux virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-use-root-privileges?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)<br><li> For a list of built-in system users on Linux that should not be used in this field, see [Selecting User Names for Linux on Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-usernames?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        adminUsername?: string;
        /**
         * Specifies the computer name prefix for all of the virtual machines in the scale set. Computer name prefixes must be 1 to 15 characters long.
         */
        computerNamePrefix?: string;
        /**
         * Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved as a file on the Virtual Machine. The maximum length of the binary array is 65535 bytes. <br><br> For using cloud-init for your VM, see [Using cloud-init to customize a Linux VM during creation](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-using-cloud-init?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json)
         */
        customData?: string;
        /**
         * Specifies the Linux operating system settings on the virtual machine. <br><br>For a list of supported Linux distributions, see [Linux on Azure-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-endorsed-distros?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json) <br><br> For running non-endorsed distributions, see [Information for Non-Endorsed Distributions](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-create-upload-generic?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
         */
        linuxConfiguration?: outputs.compute.LinuxConfigurationResponse;
        /**
         * Specifies set of certificates that should be installed onto the virtual machines in the scale set.
         */
        secrets?: outputs.compute.VaultSecretGroupResponse[];
        /**
         * Specifies Windows operating system settings on the virtual machine.
         */
        windowsConfiguration?: outputs.compute.WindowsConfigurationResponse;
    }

    /**
     * Describes the properties of a Virtual Machine Scale Set.
     */
    export interface VirtualMachineScaleSetPropertiesResponse {
        /**
         * Policy for automatic repairs.
         */
        automaticRepairsPolicy?: outputs.compute.AutomaticRepairsPolicyResponse;
        /**
         * When Overprovision is enabled, extensions are launched only on the requested number of VMs which are finally kept. This property will hence ensure that the extensions do not run on the extra overprovisioned VMs.
         */
        doNotRunExtensionsOnOverprovisionedVMs?: boolean;
        /**
         * Specifies whether the Virtual Machine Scale Set should be overprovisioned.
         */
        overprovision?: boolean;
        /**
         * Fault Domain count for each placement group.
         */
        platformFaultDomainCount?: number;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies information about the proximity placement group that the virtual machine scale set should be assigned to. <br><br>Minimum api-version: 2018-04-01.
         */
        proximityPlacementGroup?: outputs.compute.SubResourceResponse;
        /**
         * When true this limits the scale set to a single placement group, of max size 100 virtual machines.
         */
        singlePlacementGroup?: boolean;
        /**
         * Specifies the ID which uniquely identifies a Virtual Machine Scale Set.
         */
        uniqueId: string;
        /**
         * The upgrade policy.
         */
        upgradePolicy?: outputs.compute.UpgradePolicyResponse;
        /**
         * The virtual machine profile.
         */
        virtualMachineProfile?: outputs.compute.VirtualMachineScaleSetVMProfileResponse;
        /**
         * Whether to force strictly even Virtual Machine distribution cross x-zones in case there is zone outage.
         */
        zoneBalance?: boolean;
    }

    /**
     * Describes a virtual machines scale sets network configuration's DNS settings.
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsResponse {
        /**
         * The Domain name label.The concatenation of the domain name label and vm index will be the domain name labels of the PublicIPAddress resources that will be created
         */
        domainNameLabel: string;
    }

    /**
     * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesResponse {
        /**
         * The dns settings to be applied on the publicIP addresses .
         */
        dnsSettings?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationDnsSettingsResponse;
        /**
         * The idle timeout of the public IP address.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The list of IP tags associated with the public IP address.
         */
        ipTags?: outputs.compute.VirtualMachineScaleSetIpTagResponse[];
        /**
         * The PublicIPPrefix from which to allocate publicIP addresses.
         */
        publicIPPrefix?: outputs.compute.SubResourceResponse;
    }

    /**
     * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
     */
    export interface VirtualMachineScaleSetPublicIPAddressConfigurationResponse {
        /**
         * The publicIP address configuration name.
         */
        name: string;
        /**
         * Describes a virtual machines scale set IP Configuration's PublicIPAddress configuration
         */
        properties?: outputs.compute.VirtualMachineScaleSetPublicIPAddressConfigurationPropertiesResponse;
    }

    /**
     * Describes a virtual machine scale set storage profile.
     */
    export interface VirtualMachineScaleSetStorageProfileResponse {
        /**
         * Specifies the parameters that are used to add data disks to the virtual machines in the scale set. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        dataDisks?: outputs.compute.VirtualMachineScaleSetDataDiskResponse[];
        /**
         * Specifies information about the image to use. You can specify information about platform images, marketplace images, or virtual machine images. This element is required when you want to use a platform image, marketplace image, or virtual machine image, but is not used in other creation operations.
         */
        imageReference?: outputs.compute.ImageReferenceResponse;
        /**
         * Specifies information about the operating system disk used by the virtual machines in the scale set. <br><br> For more information about disks, see [About disks and VHDs for Azure virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-about-disks-vhds?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json).
         */
        osDisk?: outputs.compute.VirtualMachineScaleSetOSDiskResponse;
    }

    /**
     * The instance view of a virtual machine scale set VM.
     */
    export interface VirtualMachineScaleSetVMInstanceViewResponse {
        /**
         * Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status. <br><br> You can easily view the output of your console log. <br><br> Azure also enables you to see a screenshot of the VM from the hypervisor.
         */
        bootDiagnostics?: outputs.compute.BootDiagnosticsInstanceViewResponse;
        /**
         * The disks information.
         */
        disks?: outputs.compute.DiskInstanceViewResponse[];
        /**
         * The extensions information.
         */
        extensions?: outputs.compute.VirtualMachineExtensionInstanceViewResponse[];
        /**
         * The Maintenance Operation status on the virtual machine.
         */
        maintenanceRedeployStatus?: outputs.compute.MaintenanceRedeployStatusResponse;
        /**
         * The placement group in which the VM is running. If the VM is deallocated it will not have a placementGroupId.
         */
        placementGroupId?: string;
        /**
         * The Fault Domain count.
         */
        platformFaultDomain?: number;
        /**
         * The Update Domain count.
         */
        platformUpdateDomain?: number;
        /**
         * The Remote desktop certificate thumbprint.
         */
        rdpThumbPrint?: string;
        /**
         * The resource status information.
         */
        statuses?: outputs.compute.InstanceViewStatusResponse[];
        /**
         * The VM Agent running on the virtual machine.
         */
        vmAgent?: outputs.compute.VirtualMachineAgentInstanceViewResponse;
        /**
         * The health status for the VM.
         */
        vmHealth: outputs.compute.VirtualMachineHealthStatusResponse;
    }

    /**
     * Describes a virtual machine scale set virtual machine profile.
     */
    export interface VirtualMachineScaleSetVMProfileResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the virtual machine in the scale set. For instance: whether the virtual machine has the capability to support attaching managed data disks with UltraSSD_LRS storage account type.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the eviction policy for virtual machines in a low priority scale set. <br><br>Minimum api-version: 2017-10-30-preview
         */
        evictionPolicy?: string;
        /**
         * Specifies a collection of settings for extensions installed on virtual machines in the scale set.
         */
        extensionProfile?: outputs.compute.VirtualMachineScaleSetExtensionProfileResponse;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies properties of the network interfaces of the virtual machines in the scale set.
         */
        networkProfile?: outputs.compute.VirtualMachineScaleSetNetworkProfileResponse;
        /**
         * Specifies the operating system settings for the virtual machines in the scale set.
         */
        osProfile?: outputs.compute.VirtualMachineScaleSetOSProfileResponse;
        /**
         * Specifies the priority for the virtual machines in the scale set. <br><br>Minimum api-version: 2017-10-30-preview
         */
        priority?: string;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.VirtualMachineScaleSetStorageProfileResponse;
    }

    /**
     * Describes the properties of a virtual machine scale set virtual machine.
     */
    export interface VirtualMachineScaleSetVMPropertiesResponse {
        /**
         * Specifies additional capabilities enabled or disabled on the virtual machine in the scale set. For instance: whether the virtual machine has the capability to support attaching managed data disks with UltraSSD_LRS storage account type.
         */
        additionalCapabilities?: outputs.compute.AdditionalCapabilitiesResponse;
        /**
         * Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified in the same availability set are allocated to different nodes to maximize availability. For more information about availability sets, see [Manage the availability of virtual machines](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-manage-availability?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json). <br><br> For more information on Azure planned maintenance, see [Planned maintenance for virtual machines in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-planned-maintenance?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Currently, a VM can only be added to availability set at creation time. An existing VM cannot be added to an availability set.
         */
        availabilitySet?: outputs.compute.SubResourceResponse;
        /**
         * Specifies the boot diagnostic settings state. <br><br>Minimum api-version: 2015-06-15.
         */
        diagnosticsProfile?: outputs.compute.DiagnosticsProfileResponse;
        /**
         * Specifies the hardware settings for the virtual machine.
         */
        hardwareProfile?: outputs.compute.HardwareProfileResponse;
        /**
         * The virtual machine instance view.
         */
        instanceView: outputs.compute.VirtualMachineScaleSetVMInstanceViewResponse;
        /**
         * Specifies whether the latest model has been applied to the virtual machine.
         */
        latestModelApplied: boolean;
        /**
         * Specifies that the image or disk that is being used was licensed on-premises. This element is only used for images that contain the Windows Server operating system. <br><br> Possible values are: <br><br> Windows_Client <br><br> Windows_Server <br><br> If this element is included in a request for an update, the value must match the initial value. This value cannot be updated. <br><br> For more information, see [Azure Hybrid Use Benefit for Windows Server](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-windows-hybrid-use-benefit-licensing?toc=%2fazure%2fvirtual-machines%2fwindows%2ftoc.json) <br><br> Minimum api-version: 2015-06-15
         */
        licenseType?: string;
        /**
         * Specifies the network interfaces of the virtual machine.
         */
        networkProfile?: outputs.compute.NetworkProfileResponse;
        /**
         * Specifies the operating system settings for the virtual machine.
         */
        osProfile?: outputs.compute.OSProfileResponse;
        /**
         * The provisioning state, which only appears in the response.
         */
        provisioningState: string;
        /**
         * Specifies the storage settings for the virtual machine disks.
         */
        storageProfile?: outputs.compute.StorageProfileResponse;
        /**
         * Azure VM unique ID.
         */
        vmId: string;
    }

    /**
     * Describes Windows Remote Management configuration of the VM
     */
    export interface WinRMConfigurationResponse {
        /**
         * The list of Windows Remote Management listeners
         */
        listeners?: outputs.compute.WinRMListenerResponse[];
    }

    /**
     * Describes Protocol and thumbprint of Windows Remote Management listener
     */
    export interface WinRMListenerResponse {
        /**
         * This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault, see [Add a key or secret to the key vault](https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add). In this case, your certificate needs to be It is the Base64 encoding of the following JSON Object which is encoded in UTF-8: <br><br> {<br>  "data":"<Base64-encoded-certificate>",<br>  "dataType":"pfx",<br>  "password":"<pfx-file-password>"<br>}
         */
        certificateUrl?: string;
        /**
         * Specifies the protocol of listener. <br><br> Possible values are: <br>**http** <br><br> **https**
         */
        protocol?: string;
    }

    /**
     * Specifies Windows operating system settings on the virtual machine.
     */
    export interface WindowsConfigurationResponse {
        /**
         * Specifies additional base-64 encoded XML formatted information that can be included in the Unattend.xml file, which is used by Windows Setup.
         */
        additionalUnattendContent?: outputs.compute.AdditionalUnattendContentResponse[];
        /**
         * Indicates whether virtual machine is enabled for automatic Windows updates. Default value is true. <br><br> For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
         */
        enableAutomaticUpdates?: boolean;
        /**
         * Indicates whether virtual machine agent should be provisioned on the virtual machine. <br><br> When this property is not specified in the request body, default behavior is to set it to true.  This will ensure that VM Agent is installed on the VM so that extensions can be added to the VM later.
         */
        provisionVMAgent?: boolean;
        /**
         * Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time"
         */
        timeZone?: string;
        /**
         * Specifies the Windows Remote Management listeners. This enables remote Windows PowerShell.
         */
        winRM?: outputs.compute.WinRMConfigurationResponse;
    }
}

export namespace containerinstance {
    /**
     * The properties of the Azure File volume. Azure File shares are mounted as volumes.
     */
    export interface AzureFileVolumeResponse {
        /**
         * The flag indicating whether the Azure File shared mounted as a volume is read-only.
         */
        readOnly?: boolean;
        /**
         * The name of the Azure File share to be mounted as a volume.
         */
        shareName: string;
        /**
         * The storage account access key used to access the Azure File share.
         */
        storageAccountKey?: string;
        /**
         * The name of the storage account that contains the Azure File share.
         */
        storageAccountName: string;
    }

    /**
     * The container execution command, for liveness or readiness probe
     */
    export interface ContainerExecResponse {
        /**
         * The commands to execute within the container.
         */
        command?: string[];
    }

    /**
     * Container group diagnostic information.
     */
    export interface ContainerGroupDiagnosticsResponse {
        /**
         * Container group log analytics information.
         */
        logAnalytics?: outputs.containerinstance.LogAnalyticsResponse;
    }

    /**
     * Identity for the container group.
     */
    export interface ContainerGroupIdentityResponse {
        /**
         * The principal id of the container group identity. This property will only be provided for a system assigned identity.
         */
        principalId: string;
        /**
         * The tenant id associated with the container group. This property will only be provided for a system assigned identity.
         */
        tenantId: string;
        /**
         * The type of identity used for the container group. The type 'SystemAssigned, UserAssigned' includes both an implicitly created identity and a set of user assigned identities. The type 'None' will remove any identities from the container group.
         */
        type?: string;
        /**
         * The list of user identities associated with the container group. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Container group network profile information.
     */
    export interface ContainerGroupNetworkProfileResponse {
        /**
         * The identifier for a network profile.
         */
        id: string;
    }

    export interface ContainerGroupResponseProperties {
        /**
         * The containers within the container group.
         */
        containers: outputs.containerinstance.ContainerResponse[];
        /**
         * The diagnostic information for a container group.
         */
        diagnostics?: outputs.containerinstance.ContainerGroupDiagnosticsResponse;
        /**
         * The DNS config information for a container group.
         */
        dnsConfig?: outputs.containerinstance.DnsConfigurationResponse;
        /**
         * The image registry credentials by which the container group is created from.
         */
        imageRegistryCredentials?: outputs.containerinstance.ImageRegistryCredentialResponse[];
        /**
         * The instance view of the container group. Only valid in response.
         */
        instanceView: outputs.containerinstance.ContainerGroupResponseProperties;
        /**
         * The IP address type of the container group.
         */
        ipAddress?: outputs.containerinstance.IpAddressResponse;
        /**
         * The network profile information for a container group.
         */
        networkProfile?: outputs.containerinstance.ContainerGroupNetworkProfileResponse;
        /**
         * The operating system type required by the containers in the container group.
         */
        osType: string;
        /**
         * The provisioning state of the container group. This only appears in the response.
         */
        provisioningState: string;
        /**
         * Restart policy for all containers within the container group. 
         * - `Always` Always restart
         * - `OnFailure` Restart on failure
         * - `Never` Never restart
         */
        restartPolicy?: string;
        /**
         * The list of volumes that can be mounted by containers in this container group.
         */
        volumes?: outputs.containerinstance.VolumeResponse[];
    }

    /**
     * The container Http Get settings, for liveness or readiness probe
     */
    export interface ContainerHttpGetResponse {
        /**
         * The path to probe.
         */
        path?: string;
        /**
         * The port number to probe.
         */
        port: number;
        /**
         * The scheme.
         */
        scheme?: string;
    }

    /**
     * The port exposed on the container instance.
     */
    export interface ContainerPortResponse {
        /**
         * The port number exposed within the container group.
         */
        port: number;
        /**
         * The protocol associated with the port.
         */
        protocol?: string;
    }

    /**
     * The container probe, for liveness or readiness
     */
    export interface ContainerProbeResponse {
        /**
         * The execution command to probe
         */
        exec?: outputs.containerinstance.ContainerExecResponse;
        /**
         * The failure threshold.
         */
        failureThreshold?: number;
        /**
         * The Http Get settings to probe
         */
        httpGet?: outputs.containerinstance.ContainerHttpGetResponse;
        /**
         * The initial delay seconds.
         */
        initialDelaySeconds?: number;
        /**
         * The period seconds.
         */
        periodSeconds?: number;
        /**
         * The success threshold.
         */
        successThreshold?: number;
        /**
         * The timeout seconds.
         */
        timeoutSeconds?: number;
    }

    /**
     * The container instance properties.
     */
    export interface ContainerPropertiesResponse {
        /**
         * The commands to execute within the container instance in exec form.
         */
        command?: string[];
        /**
         * The environment variables to set in the container instance.
         */
        environmentVariables?: outputs.containerinstance.EnvironmentVariableResponse[];
        /**
         * The name of the image used to create the container instance.
         */
        image: string;
        /**
         * The instance view of the container instance. Only valid in response.
         */
        instanceView: outputs.containerinstance.ContainerPropertiesResponseProperties;
        /**
         * The liveness probe.
         */
        livenessProbe?: outputs.containerinstance.ContainerProbeResponse;
        /**
         * The exposed ports on the container instance.
         */
        ports?: outputs.containerinstance.ContainerPortResponse[];
        /**
         * The readiness probe.
         */
        readinessProbe?: outputs.containerinstance.ContainerProbeResponse;
        /**
         * The resource requirements of the container instance.
         */
        resources: outputs.containerinstance.ResourceRequirementsResponse;
        /**
         * The volume mounts available to the container instance.
         */
        volumeMounts?: outputs.containerinstance.VolumeMountResponse[];
    }

    /**
     * The instance view of the container instance. Only valid in response.
     */
    export interface ContainerPropertiesResponseProperties {
        /**
         * Current container instance state.
         */
        currentState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The events of the container instance.
         */
        events: outputs.containerinstance.EventResponse[];
        /**
         * Previous container instance state.
         */
        previousState: outputs.containerinstance.ContainerStateResponse;
        /**
         * The number of times that the container instance has been restarted.
         */
        restartCount: number;
    }

    /**
     * A container instance.
     */
    export interface ContainerResponse {
        /**
         * The user-provided name of the container instance.
         */
        name: string;
        /**
         * The properties of the container instance.
         */
        properties: outputs.containerinstance.ContainerPropertiesResponse;
    }

    /**
     * The container instance state.
     */
    export interface ContainerStateResponse {
        /**
         * The human-readable status of the container instance state.
         */
        detailStatus?: string;
        /**
         * The container instance exit codes correspond to those from the `docker run` command.
         */
        exitCode?: number;
        /**
         * The date-time when the container instance state finished.
         */
        finishTime?: string;
        /**
         * The date-time when the container instance state started.
         */
        startTime?: string;
        /**
         * The state of the container instance.
         */
        state?: string;
    }

    /**
     * DNS configuration for the container group.
     */
    export interface DnsConfigurationResponse {
        /**
         * The DNS servers for the container group.
         */
        nameServers: string[];
        /**
         * The DNS options for the container group.
         */
        options?: string;
        /**
         * The DNS search domains for hostname lookup in the container group.
         */
        searchDomains?: string;
    }

    /**
     * The empty directory volume.
     */
    export interface EmptyDirVolumeResponse {
    }

    /**
     * The environment variable to set within the container instance.
     */
    export interface EnvironmentVariableResponse {
        /**
         * The name of the environment variable.
         */
        name: string;
        /**
         * The value of the secure environment variable.
         */
        secureValue?: string;
        /**
         * The value of the environment variable.
         */
        value?: string;
    }

    /**
     * A container group or container instance event.
     */
    export interface EventResponse {
        /**
         * The count of the event.
         */
        count?: number;
        /**
         * The date-time of the earliest logged event.
         */
        firstTimestamp?: string;
        /**
         * The date-time of the latest logged event.
         */
        lastTimestamp?: string;
        /**
         * The event message.
         */
        message?: string;
        /**
         * The event name.
         */
        name?: string;
        /**
         * The event type.
         */
        type?: string;
    }

    /**
     * Represents a volume that is populated with the contents of a git repository
     */
    export interface GitRepoVolumeResponse {
        /**
         * Target directory name. Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the git repository.  Otherwise, if specified, the volume will contain the git repository in the subdirectory with the given name.
         */
        directory?: string;
        /**
         * Repository URL
         */
        repository: string;
        /**
         * Commit hash for the specified revision.
         */
        revision?: string;
    }

    /**
     * The GPU resource.
     */
    export interface GpuResourceResponse {
        /**
         * The count of the GPU resource.
         */
        count: number;
        /**
         * The SKU of the GPU resource.
         */
        sku: string;
    }

    /**
     * Image registry credential.
     */
    export interface ImageRegistryCredentialResponse {
        /**
         * The password for the private registry.
         */
        password?: string;
        /**
         * The Docker image registry server without a protocol such as "http" and "https".
         */
        server: string;
        /**
         * The username for the private registry.
         */
        username: string;
    }

    /**
     * IP address for the container group.
     */
    export interface IpAddressResponse {
        /**
         * The Dns name label for the IP.
         */
        dnsNameLabel?: string;
        /**
         * The FQDN for the IP.
         */
        fqdn: string;
        /**
         * The IP exposed to the public internet.
         */
        ip?: string;
        /**
         * The list of ports exposed on the container group.
         */
        ports: outputs.containerinstance.PortResponse[];
        /**
         * Specifies if the IP is exposed to the public internet or private VNET.
         */
        type: string;
    }

    /**
     * Container group log analytics information.
     */
    export interface LogAnalyticsResponse {
        /**
         * The log type to be used.
         */
        logType?: string;
        /**
         * Metadata for log analytics.
         */
        metadata?: {[key: string]: string};
        /**
         * The workspace id for log analytics
         */
        workspaceId: string;
        /**
         * The workspace key for log analytics
         */
        workspaceKey: string;
    }

    /**
     * The port exposed on the container group.
     */
    export interface PortResponse {
        /**
         * The port number.
         */
        port: number;
        /**
         * The protocol associated with the port.
         */
        protocol?: string;
    }

    /**
     * The resource limits.
     */
    export interface ResourceLimitsResponse {
        /**
         * The CPU limit of this container instance.
         */
        cpu?: number;
        /**
         * The GPU limit of this container instance.
         */
        gpu?: outputs.containerinstance.GpuResourceResponse;
        /**
         * The memory limit in GB of this container instance.
         */
        memoryInGB?: number;
    }

    /**
     * The resource requests.
     */
    export interface ResourceRequestsResponse {
        /**
         * The CPU request of this container instance.
         */
        cpu: number;
        /**
         * The GPU request of this container instance.
         */
        gpu?: outputs.containerinstance.GpuResourceResponse;
        /**
         * The memory request in GB of this container instance.
         */
        memoryInGB: number;
    }

    /**
     * The resource requirements.
     */
    export interface ResourceRequirementsResponse {
        /**
         * The resource limits of this container instance.
         */
        limits?: outputs.containerinstance.ResourceLimitsResponse;
        /**
         * The resource requests of this container instance.
         */
        requests: outputs.containerinstance.ResourceRequestsResponse;
    }

    /**
     * The secret volume.
     */
    export interface SecretVolumeResponse {
    }

    /**
     * The properties of the volume mount.
     */
    export interface VolumeMountResponse {
        /**
         * The path within the container where the volume should be mounted. Must not contain colon (:).
         */
        mountPath: string;
        /**
         * The name of the volume mount.
         */
        name: string;
        /**
         * The flag indicating whether the volume mount is read-only.
         */
        readOnly?: boolean;
    }

    /**
     * The properties of the volume.
     */
    export interface VolumeResponse {
        /**
         * The Azure File volume.
         */
        azureFile?: outputs.containerinstance.AzureFileVolumeResponse;
        /**
         * The empty directory volume.
         */
        emptyDir?: outputs.containerinstance.EmptyDirVolumeResponse;
        /**
         * The git repo volume.
         */
        gitRepo?: outputs.containerinstance.GitRepoVolumeResponse;
        /**
         * The name of the volume.
         */
        name: string;
        /**
         * The secret volume.
         */
        secret?: outputs.containerinstance.SecretVolumeResponse;
    }
}

export namespace core {
    /**
     * The resource group properties.
     */
    export interface ResourceGroupPropertiesResponse {
        /**
         * The provisioning state. 
         */
        provisioningState: string;
    }
}

export namespace insights {
    /**
     * Properties that define an Application Insights component resource.
     */
    export interface ApplicationInsightsComponentPropertiesResponse {
        /**
         * Application Insights Unique ID for your Application.
         */
        AppId: string;
        /**
         * The unique ID of your application. This field mirrors the 'Name' field and cannot be changed.
         */
        ApplicationId: string;
        /**
         * Type of application being monitored.
         */
        Application_Type: string;
        /**
         * Application Insights component connection string.
         */
        ConnectionString: string;
        /**
         * Creation Date for the Application Insights component, in ISO 8601 format.
         */
        CreationDate: string;
        /**
         * Disable IP masking.
         */
        DisableIpMasking?: boolean;
        /**
         * Used by the Application Insights system to determine what kind of flow this component was created by. This is to be set to 'Bluefield' when creating/updating a component via the REST API.
         */
        Flow_Type?: string;
        /**
         * The unique application ID created when a new application is added to HockeyApp, used for communications with HockeyApp.
         */
        HockeyAppId?: string;
        /**
         * Token used to authenticate communications with between Application Insights and HockeyApp.
         */
        HockeyAppToken: string;
        /**
         * Purge data immediately after 30 days.
         */
        ImmediatePurgeDataOn30Days?: boolean;
        /**
         * Indicates the flow of the ingestion.
         */
        IngestionMode?: string;
        /**
         * Application Insights Instrumentation key. A read-only value that applications can use to identify the destination for all telemetry sent to Azure Application Insights. This value will be supplied upon construction of each new Application Insights component.
         */
        InstrumentationKey: string;
        /**
         * List of linked private link scope resources.
         */
        PrivateLinkScopedResources: outputs.insights.PrivateLinkScopedResourceResponse[];
        /**
         * Describes what tool created this Application Insights component. Customers using this API should set this to the default 'rest'.
         */
        Request_Source?: string;
        /**
         * Retention period in days.
         */
        RetentionInDays?: number;
        /**
         * Percentage of the data produced by the application being monitored that is being sampled for Application Insights telemetry.
         */
        SamplingPercentage?: number;
        /**
         * Azure Tenant Id.
         */
        TenantId: string;
        /**
         * Current state of this component: whether or not is has been provisioned within the resource group it is defined. Users cannot change this value but are able to read from it. Values will include Succeeded, Deploying, Canceled, and Failed.
         */
        provisioningState: string;
    }

    /**
     * The private link scope resource reference.
     */
    export interface PrivateLinkScopedResourceResponse {
        /**
         * The full resource Id of the private link scope resource.
         */
        ResourceId?: string;
        /**
         * The private link scope unique Identifier.
         */
        ScopeId?: string;
    }
}

export namespace network {
    /**
     * AddressSpace contains an array of IP address ranges that can be used by subnets of the virtual network.
     */
    export interface AddressSpaceResponse {
        /**
         * A list of address blocks reserved for this virtual network in CIDR notation.
         */
        addressPrefixes?: string[];
    }

    /**
     * Properties of Backend Address Pool of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressPoolPropertiesFormatResponse {
        /**
         * Backend addresses
         */
        backendAddresses?: outputs.network.ApplicationGatewayBackendAddressResponse[];
        /**
         * Collection of references to IPs defined in network interfaces.
         */
        backendIPConfigurations?: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * Provisioning state of the backend address pool resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
    }

    /**
     * Backend Address Pool of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressPoolResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the backend address pool that is unique within an Application Gateway.
         */
        name?: string;
        /**
         * Properties of Backend Address Pool of an application gateway.
         */
        properties?: outputs.network.ApplicationGatewayBackendAddressPoolPropertiesFormatResponse;
        /**
         * Type of the resource.
         */
        type?: string;
    }

    /**
     * Backend address of an application gateway.
     */
    export interface ApplicationGatewayBackendAddressResponse {
        /**
         * Fully qualified domain name (FQDN).
         */
        fqdn?: string;
        /**
         * IP address
         */
        ipAddress?: string;
    }

    /**
     * Application security group properties.
     */
    export interface ApplicationSecurityGroupPropertiesFormatResponse {
        /**
         * The provisioning state of the application security group resource. Possible values are: 'Succeeded', 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the application security group resource. It uniquely identifies a resource, even if the user changes its name or migrate the resource across subscriptions or resource groups.
         */
        resourceGuid: string;
    }

    /**
     * An application security group in a resource group.
     */
    export interface ApplicationSecurityGroupResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the application security group.
         */
        properties?: outputs.network.ApplicationSecurityGroupPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of the backend address pool.
     */
    export interface BackendAddressPoolPropertiesFormatResponse {
        /**
         * Gets collection of references to IP addresses defined in network interfaces.
         */
        backendIPConfigurations: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * Gets load balancing rules that use this backend address pool.
         */
        loadBalancingRules: outputs.network.SubResourceResponse[];
        /**
         * Gets outbound rules that use this backend address pool.
         */
        outboundRule: outputs.network.SubResourceResponse;
        /**
         * Gets outbound rules that use this backend address pool.
         */
        outboundRules: outputs.network.SubResourceResponse[];
        /**
         * Get provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
    }

    /**
     * Pool of backend IP addresses.
     */
    export interface BackendAddressPoolResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer backend address pool.
         */
        properties?: outputs.network.BackendAddressPoolPropertiesFormatResponse;
    }

    /**
     * Contains the DDoS protection settings of the public IP.
     */
    export interface DdosSettingsResponse {
        /**
         * The DDoS custom policy associated with the public IP.
         */
        ddosCustomPolicy?: outputs.network.SubResourceResponse;
        /**
         * The DDoS protection policy customizability of the public IP. Only standard coverage will have the ability to be customized.
         */
        protectionCoverage?: string;
    }

    /**
     * Details the service to which the subnet is delegated.
     */
    export interface DelegationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a subnet. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the subnet.
         */
        properties?: outputs.network.ServiceDelegationPropertiesFormatResponse;
    }

    /**
     * DhcpOptions contains an array of DNS servers available to VMs deployed in the virtual network. Standard DHCP option for a subnet overrides VNET DHCP options.
     */
    export interface DhcpOptionsResponse {
        /**
         * The list of DNS servers IP addresses.
         */
        dnsServers?: string[];
    }

    /**
     * Identifies the service being brought into the virtual network.
     */
    export interface EndpointServiceResponse {
        /**
         * A unique identifier of the service being referenced by the interface endpoint.
         */
        id?: string;
    }

    /**
     * Properties of Frontend IP Configuration of the load balancer.
     */
    export interface FrontendIPConfigurationPropertiesFormatResponse {
        /**
         * Read only. Inbound pools URIs that use this frontend IP.
         */
        inboundNatPools: outputs.network.SubResourceResponse[];
        /**
         * Read only. Inbound rules URIs that use this frontend IP.
         */
        inboundNatRules: outputs.network.SubResourceResponse[];
        /**
         * Gets load balancing rules URIs that use this frontend IP.
         */
        loadBalancingRules: outputs.network.SubResourceResponse[];
        /**
         * Read only. Outbound rules URIs that use this frontend IP.
         */
        outboundRules: outputs.network.SubResourceResponse[];
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * The Private IP allocation method. Possible values are: 'Static' and 'Dynamic'.
         */
        privateIPAllocationMethod?: string;
        /**
         * Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The reference of the Public IP resource.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * The reference of the Public IP Prefix resource.
         */
        publicIPPrefix?: outputs.network.SubResourceResponse;
        /**
         * The reference of the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Frontend IP address of the load balancer.
     */
    export interface FrontendIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the load balancer probe.
         */
        properties?: outputs.network.FrontendIPConfigurationPropertiesFormatResponse;
        /**
         * A list of availability zones denoting the IP allocated for the resource needs to come from.
         */
        zones?: string[];
    }

    /**
     * IP configuration profile properties.
     */
    export interface IPConfigurationProfilePropertiesFormatResponse {
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
        /**
         * The reference of the subnet resource to create a container network interface ip configuration.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * IP configuration profile child resource.
     */
    export interface IPConfigurationProfileResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the IP configuration profile.
         */
        properties?: outputs.network.IPConfigurationProfilePropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Properties of IP configuration.
     */
    export interface IPConfigurationPropertiesFormatResponse {
        /**
         * The private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * The private IP allocation method. Possible values are 'Static' and 'Dynamic'.
         */
        privateIPAllocationMethod?: string;
        /**
         * Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The reference of the public IP resource.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * The reference of the subnet resource.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * IP configuration
     */
    export interface IPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the IP configuration
         */
        properties?: outputs.network.IPConfigurationPropertiesFormatResponse;
    }

    /**
     * Properties of the inbound NAT rule.
     */
    export interface InboundNatRulePropertiesFormatResponse {
        /**
         * A reference to a private IP address defined on a network interface of a VM. Traffic sent to the frontend port of each of the frontend IP configurations is forwarded to the backend IP.
         */
        backendIPConfiguration: outputs.network.NetworkInterfaceIPConfigurationResponse;
        /**
         * The port used for the internal endpoint. Acceptable values range from 1 to 65535.
         */
        backendPort?: number;
        /**
         * Configures a virtual machine's endpoint for the floating IP capability required to configure a SQL AlwaysOn Availability Group. This setting is required when using the SQL AlwaysOn Availability Groups in SQL server. This setting can't be changed after you create the endpoint.
         */
        enableFloatingIP?: boolean;
        /**
         * Receive bidirectional TCP Reset on TCP flow idle timeout or unexpected connection termination. This element is only used when the protocol is set to TCP.
         */
        enableTcpReset?: boolean;
        /**
         * A reference to frontend IP addresses.
         */
        frontendIPConfiguration?: outputs.network.SubResourceResponse;
        /**
         * The port for the external endpoint. Port numbers for each rule must be unique within the Load Balancer. Acceptable values range from 1 to 65534.
         */
        frontendPort?: number;
        /**
         * The timeout for the TCP idle connection. The value can be set between 4 and 30 minutes. The default value is 4 minutes. This element is only used when the protocol is set to TCP.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The transport protocol for the endpoint. Possible values are 'Udp' or 'Tcp' or 'All'.
         */
        protocol?: string;
        /**
         * Gets the provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
    }

    /**
     * Inbound NAT rule of the load balancer.
     */
    export interface InboundNatRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Gets name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of load balancer inbound nat rule.
         */
        properties?: outputs.network.InboundNatRulePropertiesFormatResponse;
    }

    /**
     * Properties of the interface endpoint.
     */
    export interface InterfaceEndpointPropertiesResponse {
        /**
         * A reference to the service being brought into the virtual network.
         */
        endpointService?: outputs.network.EndpointServiceResponse;
        /**
         * A first-party service's FQDN that is mapped to the private IP allocated via this interface endpoint.
         */
        fqdn?: string;
        /**
         * Gets an array of references to the network interfaces created for this interface endpoint.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * A read-only property that identifies who created this interface endpoint.
         */
        owner: string;
        /**
         * The provisioning state of the interface endpoint. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The ID of the subnet from which the private IP will be allocated.
         */
        subnet?: outputs.network.SubnetResponse;
    }

    /**
     * Interface endpoint resource.
     */
    export interface InterfaceEndpointResponse {
        /**
         * Gets a unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the interface endpoint.
         */
        properties?: outputs.network.InterfaceEndpointPropertiesResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Contains the IpTag associated with the object
     */
    export interface IpTagResponse {
        /**
         * Gets or sets the ipTag type: Example FirstPartyUsage.
         */
        ipTagType?: string;
        /**
         * Gets or sets value of the IpTag associated with the public IP. Example SQL, Storage etc
         */
        tag?: string;
    }

    /**
     * DNS settings of a network interface.
     */
    export interface NetworkInterfaceDnsSettingsResponse {
        /**
         * If the VM that uses this NIC is part of an Availability Set, then this list will have the union of all DNS servers from all NICs that are part of the Availability Set. This property is what is configured on each of those VMs.
         */
        appliedDnsServers?: string[];
        /**
         * List of DNS servers IP addresses. Use 'AzureProvidedDNS' to switch to azure provided DNS resolution. 'AzureProvidedDNS' value cannot be combined with other IPs, it must be the only value in dnsServers collection.
         */
        dnsServers?: string[];
        /**
         * Relative DNS name for this NIC used for internal communications between VMs in the same virtual network.
         */
        internalDnsNameLabel?: string;
        /**
         * Even if internalDnsNameLabel is not specified, a DNS entry is created for the primary NIC of the VM. This DNS name can be constructed by concatenating the VM name with the value of internalDomainNameSuffix.
         */
        internalDomainNameSuffix?: string;
        /**
         * Fully qualified DNS name supporting internal communications between VMs in the same virtual network.
         */
        internalFqdn?: string;
    }

    /**
     * Properties of IP configuration.
     */
    export interface NetworkInterfaceIPConfigurationPropertiesFormatResponse {
        /**
         * The reference of ApplicationGatewayBackendAddressPool resource.
         */
        applicationGatewayBackendAddressPools?: outputs.network.ApplicationGatewayBackendAddressPoolResponse[];
        /**
         * Application security groups in which the IP configuration is included.
         */
        applicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The reference of LoadBalancerBackendAddressPool resource.
         */
        loadBalancerBackendAddressPools?: outputs.network.BackendAddressPoolResponse[];
        /**
         * A list of references of LoadBalancerInboundNatRules.
         */
        loadBalancerInboundNatRules?: outputs.network.InboundNatRuleResponse[];
        /**
         * Gets whether this is a primary customer address on the network interface.
         */
        primary?: boolean;
        /**
         * Private IP address of the IP configuration.
         */
        privateIPAddress?: string;
        /**
         * Available from Api-Version 2016-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default is taken as IPv4.  Possible values are: 'IPv4' and 'IPv6'.
         */
        privateIPAddressVersion?: string;
        /**
         * Defines how a private IP address is assigned. Possible values are: 'Static' and 'Dynamic'.
         */
        privateIPAllocationMethod?: string;
        /**
         * The provisioning state of the network interface IP configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * Public IP address bound to the IP configuration.
         */
        publicIPAddress?: outputs.network.PublicIPAddressResponse;
        /**
         * Subnet bound to the IP configuration.
         */
        subnet?: outputs.network.SubnetResponse;
        /**
         * The reference to Virtual Network Taps.
         */
        virtualNetworkTaps?: outputs.network.VirtualNetworkTapResponse[];
    }

    /**
     * IPConfiguration in a network interface.
     */
    export interface NetworkInterfaceIPConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Network interface IP configuration properties.
         */
        properties?: outputs.network.NetworkInterfaceIPConfigurationPropertiesFormatResponse;
    }

    /**
     * NetworkInterface properties. 
     */
    export interface NetworkInterfacePropertiesFormatResponse {
        /**
         * The DNS settings in network interface.
         */
        dnsSettings?: outputs.network.NetworkInterfaceDnsSettingsResponse;
        /**
         * If the network interface is accelerated networking enabled.
         */
        enableAcceleratedNetworking?: boolean;
        /**
         * Indicates whether IP forwarding is enabled on this network interface.
         */
        enableIPForwarding?: boolean;
        /**
         * A list of references to linked BareMetal resources
         */
        hostedWorkloads: string[];
        /**
         * A reference to the interface endpoint to which the network interface is linked.
         */
        interfaceEndpoint: outputs.network.InterfaceEndpointResponse;
        /**
         * A list of IPConfigurations of the network interface.
         */
        ipConfigurations?: outputs.network.NetworkInterfaceIPConfigurationResponse[];
        /**
         * The MAC address of the network interface.
         */
        macAddress?: string;
        /**
         * The reference of the NetworkSecurityGroup resource.
         */
        networkSecurityGroup?: outputs.network.NetworkSecurityGroupResponse;
        /**
         * Gets whether this is a primary network interface on a virtual machine.
         */
        primary?: boolean;
        /**
         * The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The resource GUID property of the network interface resource.
         */
        resourceGuid?: string;
        /**
         * A list of TapConfigurations of the network interface.
         */
        tapConfigurations?: outputs.network.NetworkInterfaceTapConfigurationResponse[];
        /**
         * The reference of a virtual machine.
         */
        virtualMachine: outputs.network.SubResourceResponse;
    }

    /**
     * A network interface in a resource group.
     */
    export interface NetworkInterfaceResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the network interface.
         */
        properties?: outputs.network.NetworkInterfacePropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Properties of Virtual Network Tap configuration.
     */
    export interface NetworkInterfaceTapConfigurationPropertiesFormatResponse {
        /**
         * The provisioning state of the network interface tap configuration. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The reference of the Virtual Network Tap resource.
         */
        virtualNetworkTap?: outputs.network.VirtualNetworkTapResponse;
    }

    /**
     * Tap configuration in a Network Interface
     */
    export interface NetworkInterfaceTapConfigurationResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the Virtual Network Tap configuration
         */
        properties?: outputs.network.NetworkInterfaceTapConfigurationPropertiesFormatResponse;
        /**
         * Sub Resource type.
         */
        type: string;
    }

    /**
     * Network Security Group resource.
     */
    export interface NetworkSecurityGroupPropertiesFormatResponse {
        /**
         * The default security rules of network security group.
         */
        defaultSecurityRules?: outputs.network.SecurityRuleResponse[];
        /**
         * A collection of references to network interfaces.
         */
        networkInterfaces: outputs.network.NetworkInterfaceResponse[];
        /**
         * The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The resource GUID property of the network security group resource.
         */
        resourceGuid?: string;
        /**
         * A collection of security rules of the network security group.
         */
        securityRules?: outputs.network.SecurityRuleResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * NetworkSecurityGroup resource.
     */
    export interface NetworkSecurityGroupResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the network security group
         */
        properties?: outputs.network.NetworkSecurityGroupPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Contains FQDN of the DNS record associated with the public IP address
     */
    export interface PublicIPAddressDnsSettingsResponse {
        /**
         * Gets or sets the Domain name label.The concatenation of the domain name label and the regionalized DNS zone make up the fully qualified domain name associated with the public IP address. If a domain name label is specified, an A DNS record is created for the public IP in the Microsoft Azure DNS system.
         */
        domainNameLabel?: string;
        /**
         * Gets the FQDN, Fully qualified domain name of the A DNS record associated with the public IP. This is the concatenation of the domainNameLabel and the regionalized DNS zone.
         */
        fqdn?: string;
        /**
         * Gets or Sets the Reverse FQDN. A user-visible, fully qualified domain name that resolves to this public IP address. If the reverseFqdn is specified, then a PTR DNS record is created pointing from the IP address in the in-addr.arpa domain to the reverse FQDN. 
         */
        reverseFqdn?: string;
    }

    /**
     * Public IP address properties.
     */
    export interface PublicIPAddressPropertiesFormatResponse {
        /**
         * The DDoS protection custom policy associated with the public IP address.
         */
        ddosSettings?: outputs.network.DdosSettingsResponse;
        /**
         * The FQDN of the DNS record associated with the public IP address.
         */
        dnsSettings?: outputs.network.PublicIPAddressDnsSettingsResponse;
        /**
         * The idle timeout of the public IP address.
         */
        idleTimeoutInMinutes?: number;
        /**
         * The IP address associated with the public IP address resource.
         */
        ipAddress?: string;
        /**
         * The IP configuration associated with the public IP address.
         */
        ipConfiguration: outputs.network.IPConfigurationResponse;
        /**
         * The list of tags associated with the public IP address.
         */
        ipTags?: outputs.network.IpTagResponse[];
        /**
         * The provisioning state of the PublicIP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The public IP address version. Possible values are: 'IPv4' and 'IPv6'.
         */
        publicIPAddressVersion?: string;
        /**
         * The public IP allocation method. Possible values are: 'Static' and 'Dynamic'.
         */
        publicIPAllocationMethod?: string;
        /**
         * The Public IP Prefix this Public IP Address should be allocated from.
         */
        publicIPPrefix?: outputs.network.SubResourceResponse;
        /**
         * The resource GUID property of the public IP resource.
         */
        resourceGuid?: string;
    }

    /**
     * Public IP address resource.
     */
    export interface PublicIPAddressResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Public IP address properties.
         */
        properties?: outputs.network.PublicIPAddressPropertiesFormatResponse;
        /**
         * The public IP address SKU.
         */
        sku?: outputs.network.PublicIPAddressSkuResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
        /**
         * A list of availability zones denoting the IP allocated for the resource needs to come from.
         */
        zones?: string[];
    }

    /**
     * SKU of a public IP address
     */
    export interface PublicIPAddressSkuResponse {
        /**
         * Name of a public IP address SKU.
         */
        name?: string;
    }

    /**
     * Properties of ResourceNavigationLink.
     */
    export interface ResourceNavigationLinkFormatResponse {
        /**
         * Link to the external resource
         */
        link?: string;
        /**
         * Resource type of the linked resource.
         */
        linkedResourceType?: string;
        /**
         * Provisioning state of the ResourceNavigationLink resource.
         */
        provisioningState: string;
    }

    /**
     * ResourceNavigationLink resource.
     */
    export interface ResourceNavigationLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Resource navigation link properties format.
         */
        properties?: outputs.network.ResourceNavigationLinkFormatResponse;
    }

    /**
     * Route resource
     */
    export interface RoutePropertiesFormatResponse {
        /**
         * The destination CIDR to which the route applies.
         */
        addressPrefix?: string;
        /**
         * The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
         */
        nextHopIpAddress?: string;
        /**
         * The type of Azure hop the packet should be sent to. Possible values are: 'VirtualNetworkGateway', 'VnetLocal', 'Internet', 'VirtualAppliance', and 'None'
         */
        nextHopType: string;
        /**
         * The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
    }

    /**
     * Route resource
     */
    export interface RouteResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the route.
         */
        properties?: outputs.network.RoutePropertiesFormatResponse;
    }

    /**
     * Route Table resource
     */
    export interface RouteTablePropertiesFormatResponse {
        /**
         * Gets or sets whether to disable the routes learned by BGP on that route table. True means disable.
         */
        disableBgpRoutePropagation?: boolean;
        /**
         * The provisioning state of the resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * Collection of routes contained within a route table.
         */
        routes?: outputs.network.RouteResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * Route table resource.
     */
    export interface RouteTableResponse {
        /**
         * Gets a unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the route table.
         */
        properties?: outputs.network.RouteTablePropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Security rule resource.
     */
    export interface SecurityRulePropertiesFormatResponse {
        /**
         * The network traffic is allowed or denied. Possible values are: 'Allow' and 'Deny'.
         */
        access: string;
        /**
         * A description for this rule. Restricted to 140 chars.
         */
        description?: string;
        /**
         * The destination address prefix. CIDR or destination IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used.
         */
        destinationAddressPrefix?: string;
        /**
         * The destination address prefixes. CIDR or destination IP ranges.
         */
        destinationAddressPrefixes?: string[];
        /**
         * The application security group specified as destination.
         */
        destinationApplicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The destination port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
         */
        destinationPortRange?: string;
        /**
         * The destination port ranges.
         */
        destinationPortRanges?: string[];
        /**
         * The direction of the rule. The direction specifies if rule will be evaluated on incoming or outgoing traffic. Possible values are: 'Inbound' and 'Outbound'.
         */
        direction: string;
        /**
         * The priority of the rule. The value can be between 100 and 4096. The priority number must be unique for each rule in the collection. The lower the priority number, the higher the priority of the rule.
         */
        priority?: number;
        /**
         * Network protocol this rule applies to. Possible values are 'Tcp', 'Udp', and '*'.
         */
        protocol: string;
        /**
         * The provisioning state of the public IP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The CIDR or source IP range. Asterisk '*' can also be used to match all source IPs. Default tags such as 'VirtualNetwork', 'AzureLoadBalancer' and 'Internet' can also be used. If this is an ingress rule, specifies where network traffic originates from. 
         */
        sourceAddressPrefix?: string;
        /**
         * The CIDR or source IP ranges.
         */
        sourceAddressPrefixes?: string[];
        /**
         * The application security group specified as source.
         */
        sourceApplicationSecurityGroups?: outputs.network.ApplicationSecurityGroupResponse[];
        /**
         * The source port or range. Integer or range between 0 and 65535. Asterisk '*' can also be used to match all ports.
         */
        sourcePortRange?: string;
        /**
         * The source port ranges.
         */
        sourcePortRanges?: string[];
    }

    /**
     * Network security rule.
     */
    export interface SecurityRuleResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the security rule
         */
        properties?: outputs.network.SecurityRulePropertiesFormatResponse;
    }

    /**
     * Properties of ServiceAssociationLink.
     */
    export interface ServiceAssociationLinkPropertiesFormatResponse {
        /**
         * Link to the external resource.
         */
        link?: string;
        /**
         * Resource type of the linked resource.
         */
        linkedResourceType?: string;
        /**
         * Provisioning state of the ServiceAssociationLink resource.
         */
        provisioningState: string;
    }

    /**
     * ServiceAssociationLink resource.
     */
    export interface ServiceAssociationLinkResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Resource navigation link properties format.
         */
        properties?: outputs.network.ServiceAssociationLinkPropertiesFormatResponse;
    }

    /**
     * Properties of a service delegation.
     */
    export interface ServiceDelegationPropertiesFormatResponse {
        /**
         * Describes the actions permitted to the service upon delegation
         */
        actions?: string[];
        /**
         * The provisioning state of the resource.
         */
        provisioningState: string;
        /**
         * The name of the service to whom the subnet should be delegated (e.g. Microsoft.Sql/servers)
         */
        serviceName?: string;
    }

    /**
     * Service Endpoint policy definition resource.
     */
    export interface ServiceEndpointPolicyDefinitionPropertiesFormatResponse {
        /**
         * A description for this rule. Restricted to 140 chars.
         */
        description?: string;
        /**
         * The provisioning state of the service end point policy definition. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * Service endpoint name.
         */
        service?: string;
        /**
         * A list of service resources.
         */
        serviceResources?: string[];
    }

    /**
     * Service Endpoint policy definitions.
     */
    export interface ServiceEndpointPolicyDefinitionResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the service endpoint policy definition
         */
        properties?: outputs.network.ServiceEndpointPolicyDefinitionPropertiesFormatResponse;
    }

    /**
     * Service Endpoint Policy resource.
     */
    export interface ServiceEndpointPolicyPropertiesFormatResponse {
        /**
         * The provisioning state of the service endpoint policy. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The resource GUID property of the service endpoint policy resource.
         */
        resourceGuid: string;
        /**
         * A collection of service endpoint policy definitions of the service endpoint policy.
         */
        serviceEndpointPolicyDefinitions?: outputs.network.ServiceEndpointPolicyDefinitionResponse[];
        /**
         * A collection of references to subnets.
         */
        subnets: outputs.network.SubnetResponse[];
    }

    /**
     * Service End point policy resource.
     */
    export interface ServiceEndpointPolicyResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Properties of the service end point policy
         */
        properties?: outputs.network.ServiceEndpointPolicyPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * The service endpoint properties.
     */
    export interface ServiceEndpointPropertiesFormatResponse {
        /**
         * A list of locations.
         */
        locations?: string[];
        /**
         * The provisioning state of the resource.
         */
        provisioningState?: string;
        /**
         * The type of the endpoint service.
         */
        service?: string;
    }

    /**
     * Reference to another subresource.
     */
    export interface SubResourceResponse {
        /**
         * Resource ID.
         */
        id?: string;
    }

    /**
     * Properties of the subnet.
     */
    export interface SubnetPropertiesFormatResponse {
        /**
         * The address prefix for the subnet.
         */
        addressPrefix?: string;
        /**
         * List of  address prefixes for the subnet.
         */
        addressPrefixes?: string[];
        /**
         * Gets an array of references to the delegations on the subnet.
         */
        delegations?: outputs.network.DelegationResponse[];
        /**
         * An array of references to interface endpoints 
         */
        interfaceEndpoints: outputs.network.InterfaceEndpointResponse[];
        /**
         * Array of IP configuration profiles which reference this subnet.
         */
        ipConfigurationProfiles: outputs.network.IPConfigurationProfileResponse[];
        /**
         * Gets an array of references to the network interface IP configurations using subnet.
         */
        ipConfigurations: outputs.network.IPConfigurationResponse[];
        /**
         * The reference of the NetworkSecurityGroup resource.
         */
        networkSecurityGroup?: outputs.network.NetworkSecurityGroupResponse;
        /**
         * The provisioning state of the resource.
         */
        provisioningState?: string;
        /**
         * A read-only string identifying the intention of use for this subnet based on delegations and other user-defined properties.
         */
        purpose: string;
        /**
         * Gets an array of references to the external resources using subnet.
         */
        resourceNavigationLinks?: outputs.network.ResourceNavigationLinkResponse[];
        /**
         * The reference of the RouteTable resource.
         */
        routeTable?: outputs.network.RouteTableResponse;
        /**
         * Gets an array of references to services injecting into this subnet.
         */
        serviceAssociationLinks?: outputs.network.ServiceAssociationLinkResponse[];
        /**
         * An array of service endpoint policies.
         */
        serviceEndpointPolicies?: outputs.network.ServiceEndpointPolicyResponse[];
        /**
         * An array of service endpoints.
         */
        serviceEndpoints?: outputs.network.ServiceEndpointPropertiesFormatResponse[];
    }

    /**
     * Subnet in a virtual network resource.
     */
    export interface SubnetResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the subnet.
         */
        properties?: outputs.network.SubnetPropertiesFormatResponse;
    }

    /**
     * Properties of the virtual network peering.
     */
    export interface VirtualNetworkPeeringPropertiesFormatResponse {
        /**
         * Whether the forwarded traffic from the VMs in the remote virtual network will be allowed/disallowed.
         */
        allowForwardedTraffic?: boolean;
        /**
         * If gateway links can be used in remote virtual networking to link to this virtual network.
         */
        allowGatewayTransit?: boolean;
        /**
         * Whether the VMs in the linked virtual network space would be able to access all the VMs in local Virtual network space.
         */
        allowVirtualNetworkAccess?: boolean;
        /**
         * The status of the virtual network peering. Possible values are 'Initiated', 'Connected', and 'Disconnected'.
         */
        peeringState?: string;
        /**
         * The provisioning state of the resource.
         */
        provisioningState?: string;
        /**
         * The reference of the remote virtual network address space.
         */
        remoteAddressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * The reference of the remote virtual network. The remote virtual network can be in the same or different region (preview). See here to register for the preview and learn more (https://docs.microsoft.com/en-us/azure/virtual-network/virtual-network-create-peering).
         */
        remoteVirtualNetwork?: outputs.network.SubResourceResponse;
        /**
         * If remote gateways can be used on this virtual network. If the flag is set to true, and allowGatewayTransit on remote peering is also true, virtual network will use gateways of remote virtual network for transit. Only one peering can have this flag set to true. This flag cannot be set if virtual network already has a gateway.
         */
        useRemoteGateways?: boolean;
    }

    /**
     * Peerings in a virtual network resource.
     */
    export interface VirtualNetworkPeeringResponse {
        /**
         * A unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * The name of the resource that is unique within a resource group. This name can be used to access the resource.
         */
        name?: string;
        /**
         * Properties of the virtual network peering.
         */
        properties?: outputs.network.VirtualNetworkPeeringPropertiesFormatResponse;
    }

    /**
     * Properties of the virtual network.
     */
    export interface VirtualNetworkPropertiesFormatResponse {
        /**
         * The AddressSpace that contains an array of IP address ranges that can be used by subnets.
         */
        addressSpace?: outputs.network.AddressSpaceResponse;
        /**
         * The DDoS protection plan associated with the virtual network.
         */
        ddosProtectionPlan?: outputs.network.SubResourceResponse;
        /**
         * The dhcpOptions that contains an array of DNS servers available to VMs deployed in the virtual network.
         */
        dhcpOptions?: outputs.network.DhcpOptionsResponse;
        /**
         * Indicates if DDoS protection is enabled for all the protected resources in the virtual network. It requires a DDoS protection plan associated with the resource.
         */
        enableDdosProtection?: boolean;
        /**
         * Indicates if VM protection is enabled for all the subnets in the virtual network.
         */
        enableVmProtection?: boolean;
        /**
         * The provisioning state of the PublicIP resource. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState?: string;
        /**
         * The resourceGuid property of the Virtual Network resource.
         */
        resourceGuid?: string;
        /**
         * A list of subnets in a Virtual Network.
         */
        subnets?: outputs.network.SubnetResponse[];
        /**
         * A list of peerings in a Virtual Network.
         */
        virtualNetworkPeerings?: outputs.network.VirtualNetworkPeeringResponse[];
    }

    /**
     * Virtual Network Tap properties.
     */
    export interface VirtualNetworkTapPropertiesFormatResponse {
        /**
         * The reference to the private IP address on the internal Load Balancer that will receive the tap
         */
        destinationLoadBalancerFrontEndIPConfiguration?: outputs.network.FrontendIPConfigurationResponse;
        /**
         * The reference to the private IP Address of the collector nic that will receive the tap
         */
        destinationNetworkInterfaceIPConfiguration?: outputs.network.NetworkInterfaceIPConfigurationResponse;
        /**
         * The VXLAN destination port that will receive the tapped traffic.
         */
        destinationPort?: number;
        /**
         * Specifies the list of resource IDs for the network interface IP configuration that needs to be tapped.
         */
        networkInterfaceTapConfigurations: outputs.network.NetworkInterfaceTapConfigurationResponse[];
        /**
         * The provisioning state of the virtual network tap. Possible values are: 'Updating', 'Deleting', and 'Failed'.
         */
        provisioningState: string;
        /**
         * The resourceGuid property of the virtual network tap.
         */
        resourceGuid: string;
    }

    /**
     * Virtual Network Tap resource
     */
    export interface VirtualNetworkTapResponse {
        /**
         * Gets a unique read-only string that changes whenever the resource is updated.
         */
        etag?: string;
        /**
         * Resource ID.
         */
        id?: string;
        /**
         * Resource location.
         */
        location?: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Virtual Network Tap Properties.
         */
        properties?: outputs.network.VirtualNetworkTapPropertiesFormatResponse;
        /**
         * Resource tags.
         */
        tags?: {[key: string]: string};
        /**
         * Resource type.
         */
        type: string;
    }

}

export namespace resources {
    /**
     * The type of the paths for alias. 
     */
    export interface AliasPathTypeResponse {
        /**
         * The API versions.
         */
        apiVersions?: string[];
        /**
         * The path of an alias.
         */
        path?: string;
    }

    /**
     * The alias type. 
     */
    export interface AliasTypeResponse {
        /**
         * The alias name.
         */
        name?: string;
        /**
         * The paths for an alias.
         */
        paths?: outputs.resources.AliasPathTypeResponse[];
    }

    /**
     * Deployment dependency information.
     */
    export interface BasicDependencyResponse {
        /**
         * The ID of the dependency.
         */
        id?: string;
        /**
         * The dependency resource name.
         */
        resourceName?: string;
        /**
         * The dependency resource type.
         */
        resourceType?: string;
    }

    export interface DebugSettingResponse {
        /**
         * Specifies the type of information to log for debugging. The permitted values are none, requestContent, responseContent, or both requestContent and responseContent separated by a comma. The default is none. When setting this value, carefully consider the type of information you are passing in during deployment. By logging information about the request or response, you could potentially expose sensitive data that is retrieved through the deployment operations.
         */
        detailLevel?: string;
    }

    /**
     * Deployment dependency information.
     */
    export interface DependencyResponse {
        /**
         * The list of dependencies.
         */
        dependsOn?: outputs.resources.BasicDependencyResponse[];
        /**
         * The ID of the dependency.
         */
        id?: string;
        /**
         * The dependency resource name.
         */
        resourceName?: string;
        /**
         * The dependency resource type.
         */
        resourceType?: string;
    }

    /**
     * Deployment properties with additional details.
     */
    export interface DeploymentPropertiesExtendedResponse {
        /**
         * The correlation ID of the deployment.
         */
        correlationId: string;
        /**
         * The debug setting of the deployment.
         */
        debugSetting?: outputs.resources.DebugSettingResponse;
        /**
         * The list of deployment dependencies.
         */
        dependencies?: outputs.resources.DependencyResponse[];
        /**
         * The deployment mode. Possible values are Incremental and Complete.
         */
        mode?: string;
        /**
         * The deployment on error behavior.
         */
        onErrorDeployment?: outputs.resources.OnErrorDeploymentExtendedResponse;
        /**
         * Key/value pairs that represent deployment output.
         */
        outputs?: {[key: string]: string};
        /**
         * Deployment parameters. Use only one of Parameters or ParametersLink.
         */
        parameters?: {[key: string]: string};
        /**
         * The URI referencing the parameters. Use only one of Parameters or ParametersLink.
         */
        parametersLink?: outputs.resources.ParametersLinkResponse;
        /**
         * The list of resource providers needed for the deployment.
         */
        providers?: outputs.resources.ProviderResponse[];
        /**
         * The state of the provisioning.
         */
        provisioningState: string;
        /**
         * The template content. Use only one of Template or TemplateLink.
         */
        template?: {[key: string]: string};
        /**
         * The URI referencing the template. Use only one of Template or TemplateLink.
         */
        templateLink?: outputs.resources.TemplateLinkResponse;
        /**
         * The timestamp of the template deployment.
         */
        timestamp: string;
    }

    /**
     * Deployment on error behavior with additional details.
     */
    export interface OnErrorDeploymentExtendedResponse {
        /**
         * The deployment to be used on error case.
         */
        deploymentName?: string;
        /**
         * The state of the provisioning for the on error deployment.
         */
        provisioningState: string;
        /**
         * The deployment on error behavior type. Possible values are LastSuccessful and SpecificDeployment.
         */
        type?: string;
    }

    /**
     * Entity representing the reference to the deployment parameters.
     */
    export interface ParametersLinkResponse {
        /**
         * If included, must match the ContentVersion in the template.
         */
        contentVersion?: string;
        /**
         * The URI of the parameters file.
         */
        uri: string;
    }

    /**
     * Resource type managed by the resource provider.
     */
    export interface ProviderResourceTypeResponse {
        /**
         * The aliases that are supported by this resource type.
         */
        aliases?: outputs.resources.AliasTypeResponse[];
        /**
         * The API version.
         */
        apiVersions?: string[];
        /**
         * The collection of locations where this resource type can be created.
         */
        locations?: string[];
        /**
         * The properties.
         */
        properties?: {[key: string]: string};
        /**
         * The resource type.
         */
        resourceType?: string;
    }

    /**
     * Resource provider information.
     */
    export interface ProviderResponse {
        /**
         * The provider ID.
         */
        id: string;
        /**
         * The namespace of the resource provider.
         */
        namespace?: string;
        /**
         * The registration state of the provider.
         */
        registrationState: string;
        /**
         * The collection of provider resource types.
         */
        resourceTypes: outputs.resources.ProviderResourceTypeResponse[];
    }

    /**
     * Entity representing the reference to the template.
     */
    export interface TemplateLinkResponse {
        /**
         * If included, must match the ContentVersion in the template.
         */
        contentVersion?: string;
        /**
         * The URI of the template to deploy.
         */
        uri: string;
    }
}

export namespace sql {
    /**
     * Represents the properties of a database.
     */
    export interface DatabasePropertiesResponse {
        /**
         * The collation of the database. If createMode is not Default, this value is ignored.
         */
        collation?: string;
        /**
         * The containment state of the database.
         */
        containmentState: number;
        /**
         * Specifies the mode of database creation.
         *
         * Default: regular database creation.
         *
         * Copy: creates a database as a copy of an existing database. sourceDatabaseId must be specified as the resource ID of the source database.
         *
         * OnlineSecondary/NonReadableSecondary: creates a database as a (readable or nonreadable) secondary replica of an existing database. sourceDatabaseId must be specified as the resource ID of the existing primary database.
         *
         * PointInTimeRestore: Creates a database by restoring a point in time backup of an existing database. sourceDatabaseId must be specified as the resource ID of the existing database, and restorePointInTime must be specified.
         *
         * Recovery: Creates a database by restoring a geo-replicated backup. sourceDatabaseId must be specified as the recoverable database resource ID to restore.
         *
         * Restore: Creates a database by restoring a backup of a deleted database. sourceDatabaseId must be specified. If sourceDatabaseId is the database's original resource ID, then sourceDatabaseDeletionDate must be specified. Otherwise sourceDatabaseId must be the restorable dropped database resource ID and sourceDatabaseDeletionDate is ignored. restorePointInTime may also be specified to restore from an earlier point in time.
         *
         * RestoreLongTermRetentionBackup: Creates a database by restoring from a long term retention vault. recoveryServicesRecoveryPointResourceId must be specified as the recovery point resource ID.
         *
         * Copy, NonReadableSecondary, OnlineSecondary and RestoreLongTermRetentionBackup are not supported for DataWarehouse edition.
         */
        createMode?: string;
        /**
         * The creation date of the database (ISO8601 format).
         */
        creationDate: string;
        /**
         * The current service level objective ID of the database. This is the ID of the service level objective that is currently active.
         */
        currentServiceObjectiveId: string;
        /**
         * The ID of the database.
         */
        databaseId: string;
        /**
         * The default secondary region for this database.
         */
        defaultSecondaryLocation: string;
        /**
         * This records the earliest start date and time that restore is available for this database (ISO8601 format).
         */
        earliestRestoreDate: string;
        /**
         * The edition of the database. The DatabaseEditions enumeration contains all the valid editions. If createMode is NonReadableSecondary or OnlineSecondary, this value is ignored.
         * 
         * The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:
         * 
         * ```azurecli
         * az sql db list-editions -l <location> -o table
         * ````
         * 
         * ```powershell
         * Get-AzSqlServerServiceObjective -Location <location>
         * ````
         */
        edition?: string;
        /**
         * The name of the elastic pool the database is in. If elasticPoolName and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveName is ignored. Not supported for DataWarehouse edition.
         */
        elasticPoolName?: string;
        /**
         * The resource identifier of the failover group containing this database.
         */
        failoverGroupId: string;
        /**
         * The max size of the database expressed in bytes. If createMode is not Default, this value is ignored. To see possible values, query the capabilities API (/subscriptions/{subscriptionId}/providers/Microsoft.Sql/locations/{locationID}/capabilities) referred to by operationId: "Capabilities_ListByLocation."
         */
        maxSizeBytes?: string;
        /**
         * Conditional. If the database is a geo-secondary, readScale indicates whether read-only connections are allowed to this database or not. Not supported for DataWarehouse edition.
         */
        readScale?: string;
        /**
         * The recommended indices for this database.
         */
        recommendedIndex: outputs.sql.RecommendedIndexResponse[];
        /**
         * Conditional. If createMode is RestoreLongTermRetentionBackup, then this value is required. Specifies the resource ID of the recovery point to restore from.
         */
        recoveryServicesRecoveryPointResourceId?: string;
        /**
         * The configured service level objective ID of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of currentServiceObjectiveId property. If requestedServiceObjectiveId and requestedServiceObjectiveName are both updated, the value of requestedServiceObjectiveId overrides the value of requestedServiceObjectiveName.
         * 
         * The list of SKUs may vary by region and support offer. To determine the service objective ids that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API.
         */
        requestedServiceObjectiveId?: string;
        /**
         * The name of the configured service level objective of the database. This is the service level objective that is in the process of being applied to the database. Once successfully updated, it will match the value of serviceLevelObjective property. 
         * 
         * The list of SKUs may vary by region and support offer. To determine the SKUs (including the SKU name, tier/edition, family, and capacity) that are available to your subscription in an Azure region, use the `Capabilities_ListByLocation` REST API or one of the following commands:
         * 
         * ```azurecli
         * az sql db list-editions -l <location> -o table
         * ````
         * 
         * ```powershell
         * Get-AzSqlServerServiceObjective -Location <location>
         * ````
         */
        requestedServiceObjectiveName?: string;
        /**
         * Conditional. If createMode is PointInTimeRestore, this value is required. If createMode is Restore, this value is optional. Specifies the point in time (ISO8601 format) of the source database that will be restored to create the new database. Must be greater than or equal to the source database's earliestRestoreDate value.
         */
        restorePointInTime?: string;
        /**
         * Indicates the name of the sample schema to apply when creating this database. If createMode is not Default, this value is ignored. Not supported for DataWarehouse edition.
         */
        sampleName?: string;
        /**
         * The current service level objective of the database.
         */
        serviceLevelObjective: string;
        /**
         * The list of service tier advisors for this database. Expanded property
         */
        serviceTierAdvisors: outputs.sql.ServiceTierAdvisorResponse[];
        /**
         * Conditional. If createMode is Restore and sourceDatabaseId is the deleted database's original resource id when it existed (as opposed to its current restorable dropped database id), then this value is required. Specifies the time that the database was deleted.
         */
        sourceDatabaseDeletionDate?: string;
        /**
         * Conditional. If createMode is Copy, NonReadableSecondary, OnlineSecondary, PointInTimeRestore, Recovery, or Restore, then this value is required. Specifies the resource ID of the source database. If createMode is NonReadableSecondary or OnlineSecondary, the name of the source database must be the same as the new database being created.
         */
        sourceDatabaseId?: string;
        /**
         * The status of the database.
         */
        status: string;
        /**
         * The transparent data encryption info for this database.
         */
        transparentDataEncryption: outputs.sql.TransparentDataEncryptionResponse[];
        /**
         * Whether or not this database is zone redundant, which means the replicas of this database will be spread across multiple availability zones.
         */
        zoneRedundant?: boolean;
    }

    /**
     * The impact of an operation, both in absolute and relative terms.
     */
    export interface OperationImpactResponse {
        /**
         * The absolute impact to dimension.
         */
        changeValueAbsolute: number;
        /**
         * The relative impact to dimension (null if not applicable)
         */
        changeValueRelative: number;
        /**
         * The name of the impact dimension.
         */
        name: string;
        /**
         * The unit in which estimated impact to dimension is measured.
         */
        unit: string;
    }

    /**
     * Represents the properties of a database recommended index.
     */
    export interface RecommendedIndexPropertiesResponse {
        /**
         * The proposed index action. You can create a missing index, drop an unused index, or rebuild an existing index to improve its performance.
         */
        action: string;
        /**
         * Columns over which to build index
         */
        columns: string[];
        /**
         * The UTC datetime showing when this resource was created (ISO8601 format).
         */
        created: string;
        /**
         * The estimated impact of doing recommended index action.
         */
        estimatedImpact: outputs.sql.OperationImpactResponse[];
        /**
         * The list of column names to be included in the index
         */
        includedColumns: string[];
        /**
         * The full build index script
         */
        indexScript: string;
        /**
         * The type of index (CLUSTERED, NONCLUSTERED, COLUMNSTORE, CLUSTERED COLUMNSTORE)
         */
        indexType: string;
        /**
         * The UTC datetime of when was this resource last changed (ISO8601 format).
         */
        lastModified: string;
        /**
         * The values reported after index action is complete.
         */
        reportedImpact: outputs.sql.OperationImpactResponse[];
        /**
         * The schema where table to build index over resides
         */
        schema: string;
        /**
         * The current recommendation state.
         */
        state: string;
        /**
         * The table on which to build index.
         */
        table: string;
    }

    /**
     * Represents a database recommended index.
     */
    export interface RecommendedIndexResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * The properties representing the resource.
         */
        properties: outputs.sql.RecommendedIndexPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * Represents the properties of a server.
     */
    export interface ServerPropertiesResponse {
        /**
         * Administrator username for the server. Can only be specified when the server is being created (and is required for creation).
         */
        administratorLogin?: string;
        /**
         * The administrator login password (required for server creation).
         */
        administratorLoginPassword?: string;
        /**
         * The display name of the Azure Active Directory object with admin permissions on this server. Legacy parameter, always null. To check for Active Directory admin, query .../servers/{serverName}/administrators
         */
        externalAdministratorLogin: string;
        /**
         * The ID of the Active Azure Directory object with admin permissions on this server. Legacy parameter, always null. To check for Active Directory admin, query .../servers/{serverName}/administrators.
         */
        externalAdministratorSid: string;
        /**
         * The fully qualified domain name of the server.
         */
        fullyQualifiedDomainName: string;
        /**
         * The state of the server.
         */
        state: string;
        /**
         * The version of the server.
         */
        version?: string;
    }

    /**
     * Represents the properties of a Service Tier Advisor.
     */
    export interface ServiceTierAdvisorPropertiesResponse {
        /**
         * The activeTimeRatio for service tier advisor.
         */
        activeTimeRatio: number;
        /**
         * Gets or sets avgDtu for service tier advisor.
         */
        avgDtu: number;
        /**
         * Gets or sets confidence for service tier advisor.
         */
        confidence: number;
        /**
         * Gets or sets currentServiceLevelObjective for service tier advisor.
         */
        currentServiceLevelObjective: string;
        /**
         * Gets or sets currentServiceLevelObjectiveId for service tier advisor.
         */
        currentServiceLevelObjectiveId: string;
        /**
         * Gets or sets databaseSizeBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        databaseSizeBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets databaseSizeBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        databaseSizeBasedRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets disasterPlanBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        disasterPlanBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets disasterPlanBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        disasterPlanBasedRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets maxDtu for service tier advisor.
         */
        maxDtu: number;
        /**
         * Gets or sets maxSizeInGB for service tier advisor.
         */
        maxSizeInGB: number;
        /**
         * Gets or sets minDtu for service tier advisor.
         */
        minDtu: number;
        /**
         * The observation period start (ISO8601 format).
         */
        observationPeriodEnd: string;
        /**
         * The observation period start (ISO8601 format).
         */
        observationPeriodStart: string;
        /**
         * Gets or sets overallRecommendationServiceLevelObjective for service tier advisor.
         */
        overallRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets overallRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        overallRecommendationServiceLevelObjectiveId: string;
        /**
         * Gets or sets serviceLevelObjectiveUsageMetrics for the service tier advisor.
         */
        serviceLevelObjectiveUsageMetrics: outputs.sql.SloUsageMetricResponse[];
        /**
         * Gets or sets usageBasedRecommendationServiceLevelObjective for service tier advisor.
         */
        usageBasedRecommendationServiceLevelObjective: string;
        /**
         * Gets or sets usageBasedRecommendationServiceLevelObjectiveId for service tier advisor.
         */
        usageBasedRecommendationServiceLevelObjectiveId: string;
    }

    /**
     * Represents a Service Tier Advisor.
     */
    export interface ServiceTierAdvisorResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * The properties representing the resource.
         */
        properties: outputs.sql.ServiceTierAdvisorPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * A Slo Usage Metric.
     */
    export interface SloUsageMetricResponse {
        /**
         * Gets or sets inRangeTimeRatio for SLO usage metric.
         */
        inRangeTimeRatio: number;
        /**
         * The serviceLevelObjective for SLO usage metric.
         */
        serviceLevelObjective: string;
        /**
         * The serviceLevelObjectiveId for SLO usage metric.
         */
        serviceLevelObjectiveId: string;
    }

    /**
     * Represents the properties of a database transparent data encryption.
     */
    export interface TransparentDataEncryptionPropertiesResponse {
        /**
         * The status of the database transparent data encryption.
         */
        status?: string;
    }

    /**
     * Represents a database transparent data encryption configuration.
     */
    export interface TransparentDataEncryptionResponse {
        /**
         * Resource ID.
         */
        id: string;
        /**
         * Resource location.
         */
        location: string;
        /**
         * Resource name.
         */
        name: string;
        /**
         * Represents the properties of the resource.
         */
        properties?: outputs.sql.TransparentDataEncryptionPropertiesResponse;
        /**
         * Resource type.
         */
        type: string;
    }
}

export namespace storage {
    /**
     * Settings properties for Active Directory (AD).
     */
    export interface ActiveDirectoryPropertiesResponse {
        /**
         * Specifies the security identifier (SID) for Azure Storage.
         */
        azureStorageSid: string;
        /**
         * Specifies the domain GUID.
         */
        domainGuid: string;
        /**
         * Specifies the primary domain that the AD DNS server is authoritative for.
         */
        domainName: string;
        /**
         * Specifies the security identifier (SID).
         */
        domainSid: string;
        /**
         * Specifies the Active Directory forest to get.
         */
        forestName: string;
        /**
         * Specifies the NetBIOS domain name.
         */
        netBiosDomainName: string;
    }

    /**
     * Settings for Azure Files identity based authentication.
     */
    export interface AzureFilesIdentityBasedAuthenticationResponse {
        /**
         * Required if choose AD.
         */
        activeDirectoryProperties?: outputs.storage.ActiveDirectoryPropertiesResponse;
        /**
         * Indicates the directory service used.
         */
        directoryServiceOptions: string;
    }

    /**
     * Blob restore parameters
     */
    export interface BlobRestoreParametersResponse {
        /**
         * Blob ranges to restore.
         */
        blobRanges: outputs.storage.BlobRestoreRangeResponse[];
        /**
         * Restore blob to the specified time.
         */
        timeToRestore: string;
    }

    /**
     * Blob range
     */
    export interface BlobRestoreRangeResponse {
        /**
         * Blob end range. This is exclusive. Empty means account end.
         */
        endRange: string;
        /**
         * Blob start range. This is inclusive. Empty means account start.
         */
        startRange: string;
    }

    /**
     * Blob restore status.
     */
    export interface BlobRestoreStatusResponse {
        /**
         * Failure reason when blob restore is failed.
         */
        failureReason: string;
        /**
         * Blob restore request parameters.
         */
        parameters: outputs.storage.BlobRestoreParametersResponse;
        /**
         * Id for tracking blob restore request.
         */
        restoreId: string;
        /**
         * The status of blob restore progress. Possible values are: - InProgress: Indicates that blob restore is ongoing. - Complete: Indicates that blob restore has been completed successfully. - Failed: Indicates that blob restore is failed.
         */
        status: string;
    }

    /**
     * The properties of a container.
     */
    export interface ContainerPropertiesResponse {
        /**
         * Default the container to use specified encryption scope for all writes.
         */
        defaultEncryptionScope?: string;
        /**
         * Indicates whether the blob container was deleted.
         */
        deleted: boolean;
        /**
         * Blob container deletion time.
         */
        deletedTime: string;
        /**
         * Block override of encryption scope from the container default.
         */
        denyEncryptionScopeOverride?: boolean;
        /**
         * The hasImmutabilityPolicy public property is set to true by SRP if ImmutabilityPolicy has been created for this container. The hasImmutabilityPolicy public property is set to false by SRP if ImmutabilityPolicy has not been created for this container.
         */
        hasImmutabilityPolicy: boolean;
        /**
         * The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
         */
        hasLegalHold: boolean;
        /**
         * The ImmutabilityPolicy property of the container.
         */
        immutabilityPolicy: outputs.storage.ImmutabilityPolicyPropertiesResponse;
        /**
         * Returns the date and time the container was last modified.
         */
        lastModifiedTime: string;
        /**
         * Specifies whether the lease on a container is of infinite or fixed duration, only when the container is leased.
         */
        leaseDuration: string;
        /**
         * Lease state of the container.
         */
        leaseState: string;
        /**
         * The lease status of the container.
         */
        leaseStatus: string;
        /**
         * The LegalHold property of the container.
         */
        legalHold: outputs.storage.LegalHoldPropertiesResponse;
        /**
         * A name-value pair to associate with the container as metadata.
         */
        metadata?: {[key: string]: string};
        /**
         * Specifies whether data in the container may be accessed publicly and the level of access.
         */
        publicAccess?: string;
        /**
         * Remaining retention days for soft deleted blob container.
         */
        remainingRetentionDays: number;
        /**
         * The version of the deleted blob container.
         */
        version: string;
    }

    /**
     * The custom domain assigned to this storage account. This can be set via Update.
     */
    export interface CustomDomainResponse {
        /**
         * Gets or sets the custom domain name assigned to the storage account. Name is the CNAME source.
         */
        name: string;
        /**
         * Indicates whether indirect CName validation is enabled. Default value is false. This should only be set on updates.
         */
        useSubDomainName?: boolean;
    }

    /**
     * Object to define the number of days after creation.
     */
    export interface DateAfterCreationResponse {
        /**
         * Value indicating the age in days after creation
         */
        daysAfterCreationGreaterThan: number;
    }

    /**
     * Object to define the number of days after last modification.
     */
    export interface DateAfterModificationResponse {
        /**
         * Value indicating the age in days after last modification
         */
        daysAfterModificationGreaterThan: number;
    }

    /**
     * The encryption settings on the storage account.
     */
    export interface EncryptionResponse {
        /**
         * The encryption keySource (provider). Possible values (case-insensitive):  Microsoft.Storage, Microsoft.Keyvault
         */
        keySource: string;
        /**
         * Properties provided by key vault.
         */
        keyvaultproperties?: outputs.storage.KeyVaultPropertiesResponse;
        /**
         * A boolean indicating whether or not the service applies a secondary layer of encryption with platform managed keys for data at rest.
         */
        requireInfrastructureEncryption?: boolean;
        /**
         * List of services which support encryption.
         */
        services?: outputs.storage.EncryptionServicesResponse;
    }

    /**
     * A service that allows server-side encryption to be used.
     */
    export interface EncryptionServiceResponse {
        /**
         * A boolean indicating whether or not the service encrypts the data as it is stored.
         */
        enabled?: boolean;
        /**
         * Encryption key type to be used for the encryption service. 'Account' key type implies that an account-scoped encryption key will be used. 'Service' key type implies that a default service key is used.
         */
        keyType?: string;
        /**
         * Gets a rough estimate of the date/time when the encryption was last enabled by the user. Only returned when encryption is enabled. There might be some unencrypted blobs which were written after this time, as it is just a rough estimate.
         */
        lastEnabledTime: string;
    }

    /**
     * A list of services that support encryption.
     */
    export interface EncryptionServicesResponse {
        /**
         * The encryption function of the blob storage service.
         */
        blob?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the file storage service.
         */
        file?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the queue storage service.
         */
        queue?: outputs.storage.EncryptionServiceResponse;
        /**
         * The encryption function of the table storage service.
         */
        table?: outputs.storage.EncryptionServiceResponse;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object.
     */
    export interface EndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the internet routing storage endpoints
         */
        internetEndpoints?: outputs.storage.StorageAccountInternetEndpointsResponse;
        /**
         * Gets the microsoft routing storage endpoints.
         */
        microsoftEndpoints?: outputs.storage.StorageAccountMicrosoftEndpointsResponse;
        /**
         * Gets the queue endpoint.
         */
        queue: string;
        /**
         * Gets the table endpoint.
         */
        table: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * Statistics related to replication for storage account's Blob, Table, Queue and File services. It is only available when geo-redundant replication is enabled for the storage account.
     */
    export interface GeoReplicationStatsResponse {
        /**
         * A boolean flag which indicates whether or not account failover is supported for the account.
         */
        canFailover: boolean;
        /**
         * All primary writes preceding this UTC date/time value are guaranteed to be available for read operations. Primary writes following this point in time may or may not be available for reads. Element may be default value if value of LastSyncTime is not available, this can happen if secondary is offline or we are in bootstrap.
         */
        lastSyncTime: string;
        /**
         * The status of the secondary location. Possible values are: - Live: Indicates that the secondary location is active and operational. - Bootstrap: Indicates initial synchronization from the primary location to the secondary location is in progress.This typically occurs when replication is first enabled. - Unavailable: Indicates that the secondary location is temporarily unavailable.
         */
        status: string;
    }

    /**
     * IP rule with specific IP or IP range in CIDR format.
     */
    export interface IPRuleResponse {
        /**
         * The action of IP ACL rule.
         */
        action?: string;
        /**
         * Specifies the IP or IP range in CIDR format. Only IPV4 address is allowed.
         */
        value: string;
    }

    /**
     * Identity for the resource.
     */
    export interface IdentityResponse {
        /**
         * The principal ID of resource identity.
         */
        principalId: string;
        /**
         * The tenant ID of resource.
         */
        tenantId: string;
        /**
         * The identity type.
         */
        type: string;
    }

    /**
     * The properties of an ImmutabilityPolicy of a blob container.
     */
    export interface ImmutabilityPolicyPropertiesResponse {
        /**
         * ImmutabilityPolicy Etag.
         */
        etag: string;
        /**
         * The properties of an ImmutabilityPolicy of a blob container.
         */
        properties?: outputs.storage.ImmutabilityPolicyPropertyResponse;
        /**
         * The ImmutabilityPolicy update history of the blob container.
         */
        updateHistory: outputs.storage.UpdateHistoryPropertyResponse[];
    }

    /**
     * The properties of an ImmutabilityPolicy of a blob container.
     */
    export interface ImmutabilityPolicyPropertyResponse {
        /**
         * This property can only be changed for unlocked time-based retention policies. When enabled, new blocks can be written to an append blob while maintaining immutability protection and compliance. Only new blocks can be added and any existing blocks cannot be modified or deleted. This property cannot be changed with ExtendImmutabilityPolicy API
         */
        allowProtectedAppendWrites?: boolean;
        /**
         * The immutability period for the blobs in the container since the policy creation, in days.
         */
        immutabilityPeriodSinceCreationInDays?: number;
        /**
         * The ImmutabilityPolicy state of a blob container, possible values include: Locked and Unlocked.
         */
        state: string;
    }

    /**
     * Properties of key vault.
     */
    export interface KeyVaultPropertiesResponse {
        /**
         * The object identifier of the current versioned Key Vault Key in use.
         */
        currentVersionedKeyIdentifier: string;
        /**
         * The name of KeyVault key.
         */
        keyname?: string;
        /**
         * The Uri of KeyVault.
         */
        keyvaulturi?: string;
        /**
         * The version of KeyVault key.
         */
        keyversion?: string;
        /**
         * Timestamp of last rotation of the Key Vault Key.
         */
        lastKeyRotationTimestamp: string;
    }

    /**
     * The LegalHold property of a blob container.
     */
    export interface LegalHoldPropertiesResponse {
        /**
         * The hasLegalHold public property is set to true by SRP if there are at least one existing tag. The hasLegalHold public property is set to false by SRP if all existing legal hold tags are cleared out. There can be a maximum of 1000 blob containers with hasLegalHold=true for a given account.
         */
        hasLegalHold: boolean;
        /**
         * The list of LegalHold tags of a blob container.
         */
        tags?: outputs.storage.TagPropertyResponse[];
    }

    /**
     * Actions are applied to the filtered blobs when the execution condition is met.
     */
    export interface ManagementPolicyActionResponse {
        /**
         * The management policy action for base blob
         */
        baseBlob?: outputs.storage.ManagementPolicyBaseBlobResponse;
        /**
         * The management policy action for snapshot
         */
        snapshot?: outputs.storage.ManagementPolicySnapShotResponse;
    }

    /**
     * Management policy action for base blob.
     */
    export interface ManagementPolicyBaseBlobResponse {
        /**
         * The function to delete the blob
         */
        delete?: outputs.storage.DateAfterModificationResponse;
        /**
         * The function to tier blobs to archive storage. Support blobs currently at Hot or Cool tier
         */
        tierToArchive?: outputs.storage.DateAfterModificationResponse;
        /**
         * The function to tier blobs to cool storage. Support blobs currently at Hot tier
         */
        tierToCool?: outputs.storage.DateAfterModificationResponse;
    }

    /**
     * An object that defines the Lifecycle rule. Each definition is made up with a filters set and an actions set.
     */
    export interface ManagementPolicyDefinitionResponse {
        /**
         * An object that defines the action set.
         */
        actions: outputs.storage.ManagementPolicyActionResponse;
        /**
         * An object that defines the filter set.
         */
        filters?: outputs.storage.ManagementPolicyFilterResponse;
    }

    /**
     * Filters limit rule actions to a subset of blobs within the storage account. If multiple filters are defined, a logical AND is performed on all filters. 
     */
    export interface ManagementPolicyFilterResponse {
        /**
         * An array of blob index tag based filters, there can be at most 10 tag filters
         */
        blobIndexMatch?: outputs.storage.TagFilterResponse[];
        /**
         * An array of predefined enum values. Only blockBlob is supported.
         */
        blobTypes: string[];
        /**
         * An array of strings for prefixes to be match.
         */
        prefixMatch?: string[];
    }

    /**
     * The Storage Account ManagementPolicy properties.
     */
    export interface ManagementPolicyPropertiesResponse {
        /**
         * Returns the date and time the ManagementPolicies was last modified.
         */
        lastModifiedTime: string;
        /**
         * The Storage Account ManagementPolicy, in JSON format. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
         */
        policy: outputs.storage.ManagementPolicySchemaResponse;
    }

    /**
     * An object that wraps the Lifecycle rule. Each rule is uniquely defined by name.
     */
    export interface ManagementPolicyRuleResponse {
        /**
         * An object that defines the Lifecycle rule.
         */
        definition: outputs.storage.ManagementPolicyDefinitionResponse;
        /**
         * Rule is enabled if set to true.
         */
        enabled?: boolean;
        /**
         * A rule name can contain any combination of alpha numeric characters. Rule name is case-sensitive. It must be unique within a policy.
         */
        name: string;
        /**
         * The valid value is Lifecycle
         */
        type: string;
    }

    /**
     * The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
     */
    export interface ManagementPolicySchemaResponse {
        /**
         * The Storage Account ManagementPolicies Rules. See more details in: https://docs.microsoft.com/en-us/azure/storage/common/storage-lifecycle-managment-concepts.
         */
        rules: outputs.storage.ManagementPolicyRuleResponse[];
    }

    /**
     * Management policy action for snapshot.
     */
    export interface ManagementPolicySnapShotResponse {
        /**
         * The function to delete the blob snapshot
         */
        delete?: outputs.storage.DateAfterCreationResponse;
    }

    /**
     * Network rule set
     */
    export interface NetworkRuleSetResponse {
        /**
         * Specifies whether traffic is bypassed for Logging/Metrics/AzureServices. Possible values are any combination of Logging|Metrics|AzureServices (For example, "Logging, Metrics"), or None to bypass none of those traffics.
         */
        bypass?: string;
        /**
         * Specifies the default action of allow or deny when no other rules match.
         */
        defaultAction: string;
        /**
         * Sets the IP ACL rules
         */
        ipRules?: outputs.storage.IPRuleResponse[];
        /**
         * Sets the virtual network rules
         */
        virtualNetworkRules?: outputs.storage.VirtualNetworkRuleResponse[];
    }

    /**
     * Filters limit replication to a subset of blobs within the storage account. A logical OR is performed on values in the filter. If multiple filters are defined, a logical AND is performed on all filters.
     */
    export interface ObjectReplicationPolicyFilterResponse {
        /**
         * Blobs created after the time will be replicated to the destination. It must be in datetime format 'yyyy-MM-ddTHH:mm:ssZ'. Example: 2020-02-19T16:05:00Z
         */
        minCreationTime?: string;
        /**
         * Optional. Filters the results to replicate only blobs whose names begin with the specified prefix.
         */
        prefixMatch?: string[];
    }

    /**
     * The Storage Account ObjectReplicationPolicy properties.
     */
    export interface ObjectReplicationPolicyPropertiesResponse {
        /**
         * Required. Destination account name.
         */
        destinationAccount: string;
        /**
         * Indicates when the policy is enabled on the source account.
         */
        enabledTime: string;
        /**
         * A unique id for object replication policy.
         */
        policyId: string;
        /**
         * The storage account object replication rules.
         */
        rules?: outputs.storage.ObjectReplicationPolicyRuleResponse[];
        /**
         * Required. Source account name.
         */
        sourceAccount: string;
    }

    /**
     * The replication policy rule between two containers.
     */
    export interface ObjectReplicationPolicyRuleResponse {
        /**
         * Required. Destination container name.
         */
        destinationContainer: string;
        /**
         * Optional. An object that defines the filter set.
         */
        filters?: outputs.storage.ObjectReplicationPolicyFilterResponse;
        /**
         * Rule Id is auto-generated for each new rule on destination account. It is required for put policy on source account.
         */
        ruleId?: string;
        /**
         * Required. Source container name.
         */
        sourceContainer: string;
    }

    /**
     * Properties of the PrivateEndpointConnectProperties.
     */
    export interface PrivateEndpointConnectionPropertiesResponse {
        /**
         * The resource of private end point.
         */
        privateEndpoint?: outputs.storage.PrivateEndpointResponse;
        /**
         * A collection of information about the state of the connection between service consumer and provider.
         */
        privateLinkServiceConnectionState: outputs.storage.PrivateLinkServiceConnectionStateResponse;
        /**
         * The provisioning state of the private endpoint connection resource.
         */
        provisioningState?: string;
    }

    /**
     * The Private Endpoint Connection resource.
     */
    export interface PrivateEndpointConnectionResponse {
        /**
         * Fully qualified resource Id for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
         */
        id: string;
        /**
         * The name of the resource
         */
        name: string;
        /**
         * Resource properties.
         */
        properties?: outputs.storage.PrivateEndpointConnectionPropertiesResponse;
        /**
         * The type of the resource. Ex- Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
         */
        type: string;
    }

    /**
     * The Private Endpoint resource.
     */
    export interface PrivateEndpointResponse {
        /**
         * The ARM identifier for Private Endpoint
         */
        id: string;
    }

    /**
     * A collection of information about the state of the connection between service consumer and provider.
     */
    export interface PrivateLinkServiceConnectionStateResponse {
        /**
         * A message indicating if changes on the service provider require any updates on the consumer.
         */
        actionRequired?: string;
        /**
         * The reason for approval/rejection of the connection.
         */
        description?: string;
        /**
         * Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
         */
        status?: string;
    }

    /**
     * Routing preference defines the type of network, either microsoft or internet routing to be used to deliver the user data, the default option is microsoft routing
     */
    export interface RoutingPreferenceResponse {
        /**
         * A boolean flag which indicates whether internet routing storage endpoints are to be published
         */
        publishInternetEndpoints?: boolean;
        /**
         * A boolean flag which indicates whether microsoft routing storage endpoints are to be published
         */
        publishMicrosoftEndpoints?: boolean;
        /**
         * Routing Choice defines the kind of network routing opted by the user.
         */
        routingChoice?: string;
    }

    /**
     * The SKU of the storage account.
     */
    export interface SkuResponse {
        /**
         * The SKU name. Required for account creation; optional for update. Note that in older versions, SKU name was called accountType.
         */
        name: string;
        /**
         * The SKU tier. This is based on the SKU name.
         */
        tier?: string;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, file, web or dfs object via a internet routing endpoint.
     */
    export interface StorageAccountInternetEndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * The URIs that are used to perform a retrieval of a public blob, queue, table, web or dfs object via a microsoft routing endpoint.
     */
    export interface StorageAccountMicrosoftEndpointsResponse {
        /**
         * Gets the blob endpoint.
         */
        blob: string;
        /**
         * Gets the dfs endpoint.
         */
        dfs: string;
        /**
         * Gets the file endpoint.
         */
        file: string;
        /**
         * Gets the queue endpoint.
         */
        queue: string;
        /**
         * Gets the table endpoint.
         */
        table: string;
        /**
         * Gets the web endpoint.
         */
        web: string;
    }

    /**
     * Properties of the storage account.
     */
    export interface StorageAccountPropertiesResponse {
        /**
         * Required for storage accounts where kind = BlobStorage. The access tier used for billing.
         */
        accessTier: string;
        /**
         * Provides the identity based authentication settings for Azure Files.
         */
        azureFilesIdentityBasedAuthentication?: outputs.storage.AzureFilesIdentityBasedAuthenticationResponse;
        /**
         * Blob restore status
         */
        blobRestoreStatus: outputs.storage.BlobRestoreStatusResponse;
        /**
         * Gets the creation date and time of the storage account in UTC.
         */
        creationTime: string;
        /**
         * Gets the custom domain the user assigned to this storage account.
         */
        customDomain: outputs.storage.CustomDomainResponse;
        /**
         * Gets the encryption settings on the account. If unspecified, the account is unencrypted.
         */
        encryption: outputs.storage.EncryptionResponse;
        /**
         * If the failover is in progress, the value will be true, otherwise, it will be null.
         */
        failoverInProgress: boolean;
        /**
         * Geo Replication Stats
         */
        geoReplicationStats: outputs.storage.GeoReplicationStatsResponse;
        /**
         * Account HierarchicalNamespace enabled if sets to true.
         */
        isHnsEnabled?: boolean;
        /**
         * Allow large file shares if sets to Enabled. It cannot be disabled once it is enabled.
         */
        largeFileSharesState?: string;
        /**
         * Gets the timestamp of the most recent instance of a failover to the secondary location. Only the most recent timestamp is retained. This element is not returned if there has never been a failover instance. Only available if the accountType is Standard_GRS or Standard_RAGRS.
         */
        lastGeoFailoverTime: string;
        /**
         * Network rule set
         */
        networkAcls: outputs.storage.NetworkRuleSetResponse;
        /**
         * Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object. Note that Standard_ZRS and Premium_LRS accounts only return the blob endpoint.
         */
        primaryEndpoints: outputs.storage.EndpointsResponse;
        /**
         * Gets the location of the primary data center for the storage account.
         */
        primaryLocation: string;
        /**
         * List of private endpoint connection associated with the specified storage account
         */
        privateEndpointConnections: outputs.storage.PrivateEndpointConnectionResponse[];
        /**
         * Gets the status of the storage account at the time the operation was called.
         */
        provisioningState: string;
        /**
         * Maintains information about the network routing choice opted by the user for data transfer
         */
        routingPreference?: outputs.storage.RoutingPreferenceResponse;
        /**
         * Gets the URLs that are used to perform a retrieval of a public blob, queue, or table object from the secondary location of the storage account. Only available if the SKU name is Standard_RAGRS.
         */
        secondaryEndpoints: outputs.storage.EndpointsResponse;
        /**
         * Gets the location of the geo-replicated secondary for the storage account. Only available if the accountType is Standard_GRS or Standard_RAGRS.
         */
        secondaryLocation: string;
        /**
         * Gets the status indicating whether the primary location of the storage account is available or unavailable.
         */
        statusOfPrimary: string;
        /**
         * Gets the status indicating whether the secondary location of the storage account is available or unavailable. Only available if the SKU name is Standard_GRS or Standard_RAGRS.
         */
        statusOfSecondary: string;
        /**
         * Allows https traffic only to storage service if sets to true.
         */
        supportsHttpsTrafficOnly?: boolean;
    }

    /**
     * Blob index tag based filtering for blob objects
     */
    export interface TagFilterResponse {
        /**
         * This is the filter tag name, it can have 1 - 128 characters
         */
        name: string;
        /**
         * This is the comparison operator which is used for object comparison and filtering. Only == (equality operator) is currently supported
         */
        op: string;
        /**
         * This is the filter tag value field used for tag based filtering, it can have 0 - 256 characters
         */
        value: string;
    }

    /**
     * A tag of the LegalHold of a blob container.
     */
    export interface TagPropertyResponse {
        /**
         * Returns the Object ID of the user who added the tag.
         */
        objectIdentifier: string;
        /**
         * The tag value.
         */
        tag: string;
        /**
         * Returns the Tenant ID that issued the token for the user who added the tag.
         */
        tenantId: string;
        /**
         * Returns the date and time the tag was added.
         */
        timestamp: string;
        /**
         * Returns the User Principal Name of the user who added the tag.
         */
        upn: string;
    }

    /**
     * An update history of the ImmutabilityPolicy of a blob container.
     */
    export interface UpdateHistoryPropertyResponse {
        /**
         * The immutability period for the blobs in the container since the policy creation, in days.
         */
        immutabilityPeriodSinceCreationInDays: number;
        /**
         * Returns the Object ID of the user who updated the ImmutabilityPolicy.
         */
        objectIdentifier: string;
        /**
         * Returns the Tenant ID that issued the token for the user who updated the ImmutabilityPolicy.
         */
        tenantId: string;
        /**
         * Returns the date and time the ImmutabilityPolicy was updated.
         */
        timestamp: string;
        /**
         * The ImmutabilityPolicy update type of a blob container, possible values include: put, lock and extend.
         */
        update: string;
        /**
         * Returns the User Principal Name of the user who updated the ImmutabilityPolicy.
         */
        upn: string;
    }

    /**
     * Virtual Network rule.
     */
    export interface VirtualNetworkRuleResponse {
        /**
         * The action of virtual network rule.
         */
        action?: string;
        /**
         * Resource ID of a subnet, for example: /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{vnetName}/subnets/{subnetName}.
         */
        id: string;
        /**
         * Gets the state of virtual network rule.
         */
        state?: string;
    }
}

export namespace web {
    /**
     * Information about the formal API definition for the app.
     */
    export interface ApiDefinitionInfoResponse {
        /**
         * The URL of the API definition.
         */
        url?: string;
    }

    /**
     * Azure API management (APIM) configuration linked to the app.
     */
    export interface ApiManagementConfigResponse {
        /**
         * APIM-Api Identifier.
         */
        id?: string;
    }

    /**
     * AppServicePlan resource specific properties
     */
    export interface AppServicePlanResponseProperties {
        /**
         * The time when the server farm free offer expires.
         */
        freeOfferExpirationTime?: string;
        /**
         * Geographical location for the App Service plan.
         */
        geoRegion: string;
        /**
         * Specification for the App Service Environment to use for the App Service plan.
         */
        hostingEnvironmentProfile?: outputs.web.HostingEnvironmentProfileResponse;
        /**
         * If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
         */
        hyperV?: boolean;
        /**
         * If <code>true</code>, this App Service Plan owns spot instances.
         */
        isSpot?: boolean;
        /**
         * Obsolete: If Hyper-V container app service plan <code>true</code>, <code>false</code> otherwise.
         */
        isXenon?: boolean;
        /**
         * Maximum number of total workers allowed for this ElasticScaleEnabled App Service Plan
         */
        maximumElasticWorkerCount?: number;
        /**
         * Maximum number of instances that can be assigned to this App Service plan.
         */
        maximumNumberOfWorkers: number;
        /**
         * Number of apps assigned to this App Service plan.
         */
        numberOfSites: number;
        /**
         * If <code>true</code>, apps assigned to this App Service plan can be scaled independently.
         * If <code>false</code>, apps assigned to this App Service plan will scale to all instances of the plan.
         */
        perSiteScaling?: boolean;
        /**
         * Provisioning state of the App Service Environment.
         */
        provisioningState: string;
        /**
         * If Linux app service plan <code>true</code>, <code>false</code> otherwise.
         */
        reserved?: boolean;
        /**
         * Resource group of the App Service plan.
         */
        resourceGroup: string;
        /**
         * The time when the server farm expires. Valid only if it is a spot server farm.
         */
        spotExpirationTime?: string;
        /**
         * App Service plan status.
         */
        status: string;
        /**
         * App Service plan subscription.
         */
        subscription: string;
        /**
         * Scaling worker count.
         */
        targetWorkerCount?: number;
        /**
         * Scaling worker size ID.
         */
        targetWorkerSizeId?: number;
        /**
         * Target worker tier assigned to the App Service plan.
         */
        workerTierName?: string;
    }

    /**
     * A wrapper for an ARM resource id
     */
    export interface ArmIdWrapperResponse {
        id: string;
    }

    /**
     * Actions which to take by the auto-heal module when a rule is triggered.
     */
    export interface AutoHealActionsResponse {
        /**
         * Predefined action to be taken.
         */
        actionType?: string;
        /**
         * Custom action to be taken.
         */
        customAction?: outputs.web.AutoHealCustomActionResponse;
        /**
         * Minimum time the process must execute
         * before taking the action
         */
        minProcessExecutionTime?: string;
    }

    /**
     * Custom action to be executed
     * when an auto heal rule is triggered.
     */
    export interface AutoHealCustomActionResponse {
        /**
         * Executable to be run.
         */
        exe?: string;
        /**
         * Parameters for the executable.
         */
        parameters?: string;
    }

    /**
     * Rules that can be defined for auto-heal.
     */
    export interface AutoHealRulesResponse {
        /**
         * Actions to be executed when a rule is triggered.
         */
        actions?: outputs.web.AutoHealActionsResponse;
        /**
         * Conditions that describe when to execute the auto-heal actions.
         */
        triggers?: outputs.web.AutoHealTriggersResponse;
    }

    /**
     * Triggers for auto-heal.
     */
    export interface AutoHealTriggersResponse {
        /**
         * A rule based on private bytes.
         */
        privateBytesInKB?: number;
        /**
         * A rule based on total requests.
         */
        requests?: outputs.web.RequestsBasedTriggerResponse;
        /**
         * A rule based on request execution time.
         */
        slowRequests?: outputs.web.SlowRequestsBasedTriggerResponse;
        /**
         * A rule based on status codes.
         */
        statusCodes?: outputs.web.StatusCodesBasedTriggerResponse[];
    }

    /**
     * Describes the capabilities/features allowed for a specific SKU.
     */
    export interface CapabilityResponse {
        /**
         * Name of the SKU capability.
         */
        name?: string;
        /**
         * Reason of the SKU capability.
         */
        reason?: string;
        /**
         * Value of the SKU capability.
         */
        value?: string;
    }

    /**
     * Information needed for cloning operation.
     */
    export interface CloningInfoResponse {
        /**
         * Application setting overrides for cloned app. If specified, these settings override the settings cloned 
         * from source app. Otherwise, application settings from source app are retained.
         */
        appSettingsOverrides?: {[key: string]: string};
        /**
         * <code>true</code> to clone custom hostnames from source app; otherwise, <code>false</code>.
         */
        cloneCustomHostNames?: boolean;
        /**
         * <code>true</code> to clone source control from source app; otherwise, <code>false</code>.
         */
        cloneSourceControl?: boolean;
        /**
         * <code>true</code> to configure load balancing for source and destination app.
         */
        configureLoadBalancing?: boolean;
        /**
         * Correlation ID of cloning operation. This ID ties multiple cloning operations
         * together to use the same snapshot.
         */
        correlationId?: string;
        /**
         * App Service Environment.
         */
        hostingEnvironment?: string;
        /**
         * <code>true</code> to overwrite destination app; otherwise, <code>false</code>.
         */
        overwrite?: boolean;
        /**
         * ARM resource ID of the source app. App resource ID is of the form 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName} for production slots and 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Web/sites/{siteName}/slots/{slotName} for other slots.
         */
        sourceWebAppId: string;
        /**
         * Location of source app ex: West US or North Europe
         */
        sourceWebAppLocation?: string;
        /**
         * ARM resource ID of the Traffic Manager profile to use, if it exists. Traffic Manager resource ID is of the form 
         * /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Network/trafficManagerProfiles/{profileName}.
         */
        trafficManagerProfileId?: string;
        /**
         * Name of Traffic Manager profile to create. This is only needed if Traffic Manager profile does not already exist.
         */
        trafficManagerProfileName?: string;
    }

    /**
     * Database connection string information.
     */
    export interface ConnStringInfoResponse {
        /**
         * Connection string value.
         */
        connectionString?: string;
        /**
         * Name of connection string.
         */
        name?: string;
        /**
         * Type of database.
         */
        type?: string;
    }

    /**
     * Cross-Origin Resource Sharing (CORS) settings for the app.
     */
    export interface CorsSettingsResponse {
        /**
         * Gets or sets the list of origins that should be allowed to make cross-origin
         * calls (for example: http://example.com:12345). Use "*" to allow all.
         */
        allowedOrigins?: string[];
        /**
         * Gets or sets whether CORS requests with credentials are allowed. See 
         * https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Requests_with_credentials
         * for more details.
         */
        supportCredentials?: boolean;
    }

    /**
     * Deployment resource specific properties
     */
    export interface DeploymentResponseProperties {
        /**
         * True if deployment is currently active, false if completed and null if not started.
         */
        active?: boolean;
        /**
         * Who authored the deployment.
         */
        author?: string;
        /**
         * Author email.
         */
        author_email?: string;
        /**
         * Who performed the deployment.
         */
        deployer?: string;
        /**
         * Details on deployment.
         */
        details?: string;
        /**
         * End time.
         */
        end_time?: string;
        /**
         * Details about deployment status.
         */
        message?: string;
        /**
         * Start time.
         */
        start_time?: string;
        /**
         * Deployment status.
         */
        status?: number;
    }

    /**
     * Routing rules in production experiments.
     */
    export interface ExperimentsResponse {
        /**
         * List of ramp-up rules.
         */
        rampUpRules?: outputs.web.RampUpRuleResponse[];
    }

    /**
     * FunctionEnvelope resource specific properties
     */
    export interface FunctionEnvelopeResponseProperties {
        /**
         * Config information.
         */
        config?: {[key: string]: string};
        /**
         * Config URI.
         */
        config_href?: string;
        /**
         * File list.
         */
        files?: {[key: string]: string};
        /**
         * Function App ID.
         */
        function_app_id?: string;
        /**
         * Function URI.
         */
        href?: string;
        /**
         * The invocation URL
         */
        invoke_url_template?: string;
        /**
         * Gets or sets a value indicating whether the function is disabled
         */
        isDisabled?: boolean;
        /**
         * The function language
         */
        language?: string;
        /**
         * Script URI.
         */
        script_href?: string;
        /**
         * Script root path URI.
         */
        script_root_path_href?: string;
        /**
         * Secrets file URI.
         */
        secrets_file_href?: string;
        /**
         * Test data used when testing via the Azure Portal.
         */
        test_data?: string;
        /**
         * Test data URI.
         */
        test_data_href?: string;
    }

    /**
     * The IIS handler mappings used to define which handler processes HTTP requests with certain extension. 
     * For example, it is used to configure php-cgi.exe process to handle all HTTP requests with *.php extension.
     */
    export interface HandlerMappingResponse {
        /**
         * Command-line arguments to be passed to the script processor.
         */
        arguments?: string;
        /**
         * Requests with this extension will be handled using the specified FastCGI application.
         */
        extension?: string;
        /**
         * The absolute path to the FastCGI application.
         */
        scriptProcessor?: string;
    }

    /**
     * HostNameBinding resource specific properties
     */
    export interface HostNameBindingResponseProperties {
        /**
         * Azure resource name.
         */
        azureResourceName?: string;
        /**
         * Azure resource type.
         */
        azureResourceType?: string;
        /**
         * Custom DNS record type.
         */
        customHostNameDnsRecordType?: string;
        /**
         * Fully qualified ARM domain resource URI.
         */
        domainId?: string;
        /**
         * Hostname type.
         */
        hostNameType?: string;
        /**
         * App Service app name.
         */
        siteName?: string;
        /**
         * SSL type
         */
        sslState?: string;
        /**
         * SSL certificate thumbprint
         */
        thumbprint?: string;
        /**
         * Virtual IP address assigned to the hostname if IP based SSL is enabled.
         */
        virtualIP: string;
    }

    /**
     * SSL-enabled hostname.
     */
    export interface HostNameSslStateResponse {
        /**
         * Indicates whether the hostname is a standard or repository hostname.
         */
        hostType?: string;
        /**
         * Hostname.
         */
        name?: string;
        /**
         * SSL type.
         */
        sslState?: string;
        /**
         * SSL certificate thumbprint.
         */
        thumbprint?: string;
        /**
         * Set to <code>true</code> to update existing hostname.
         */
        toUpdate?: boolean;
        /**
         * Virtual IP address assigned to the hostname if IP based SSL is enabled.
         */
        virtualIP?: string;
    }

    /**
     * Specification for an App Service Environment to use for this resource.
     */
    export interface HostingEnvironmentProfileResponse {
        /**
         * Resource ID of the App Service Environment.
         */
        id?: string;
        /**
         * Name of the App Service Environment.
         */
        name: string;
        /**
         * Resource type of the App Service Environment.
         */
        type: string;
    }

    /**
     * HybridConnection resource specific properties
     */
    export interface HybridConnectionResponseProperties {
        /**
         * The hostname of the endpoint.
         */
        hostname?: string;
        /**
         * The port of the endpoint.
         */
        port?: number;
        /**
         * The ARM URI to the Service Bus relay.
         */
        relayArmUri?: string;
        /**
         * The name of the Service Bus relay.
         */
        relayName?: string;
        /**
         * The name of the Service Bus key which has Send permissions. This is used to authenticate to Service Bus.
         */
        sendKeyName?: string;
        /**
         * The value of the Service Bus key. This is used to authenticate to Service Bus. In ARM this key will not be returned
         * normally, use the POST /listKeys API instead.
         */
        sendKeyValue?: string;
        /**
         * The name of the Service Bus namespace.
         */
        serviceBusNamespace?: string;
        /**
         * The suffix for the service bus endpoint. By default this is .servicebus.windows.net
         */
        serviceBusSuffix?: string;
    }

    /**
     * Identifier resource specific properties
     */
    export interface IdentifierResponseProperties {
        /**
         * String representation of the identity.
         */
        id?: string;
    }

    /**
     * IP security restriction on an app.
     */
    export interface IpSecurityRestrictionResponse {
        /**
         * Allow or Deny access for this IP range.
         */
        action?: string;
        /**
         * IP restriction rule description.
         */
        description?: string;
        /**
         * IP address the security restriction is valid for.
         * It can be in form of pure ipv4 address (required SubnetMask property) or
         * CIDR notation such as ipv4/mask (leading bit match). For CIDR,
         * SubnetMask property must not be specified.
         */
        ipAddress?: string;
        /**
         * IP restriction rule name.
         */
        name?: string;
        /**
         * Priority of IP restriction rule.
         */
        priority?: number;
        /**
         * Subnet mask for the range of IP addresses the restriction is valid for.
         */
        subnetMask?: string;
        /**
         * (internal) Subnet traffic tag
         */
        subnetTrafficTag?: number;
        /**
         * Defines what this IP filter will be used for. This is to support IP filtering on proxies.
         */
        tag?: string;
        /**
         * Virtual network resource id
         */
        vnetSubnetResourceId?: string;
        /**
         * (internal) Vnet traffic tag
         */
        vnetTrafficTag?: number;
    }

    /**
     * Managed service identity.
     */
    export interface ManagedServiceIdentityResponse {
        /**
         * Principal Id of managed service identity.
         */
        principalId: string;
        /**
         * Tenant of managed service identity.
         */
        tenantId: string;
        /**
         * Type of managed service identity.
         */
        type?: string;
        /**
         * The list of user assigned identities associated with the resource. The user identity dictionary key references will be ARM resource ids in the form: '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}
         */
        userAssignedIdentities?: {[key: string]: string};
    }

    /**
     * Name value pair.
     */
    export interface NameValuePairResponse {
        /**
         * Pair name.
         */
        name?: string;
        /**
         * Pair value.
         */
        value?: string;
    }

    /**
     * PremierAddOn resource specific properties
     */
    export interface PremierAddOnResponseProperties {
        /**
         * Premier add on Marketplace offer.
         */
        marketplaceOffer?: string;
        /**
         * Premier add on Marketplace publisher.
         */
        marketplacePublisher?: string;
        /**
         * Premier add on Product.
         */
        product?: string;
        /**
         * Premier add on SKU.
         */
        sku?: string;
        /**
         * Premier add on Vendor.
         */
        vendor?: string;
    }

    /**
     * The state of a private link connection
     */
    export interface PrivateLinkConnectionStateResponse {
        /**
         * ActionsRequired for a private link connection
         */
        actionsRequired?: string;
        /**
         * Description of a private link connection
         */
        description?: string;
        /**
         * Status of a private link connection
         */
        status?: string;
    }

    /**
     * PublicCertificate resource specific properties
     */
    export interface PublicCertificateResponseProperties {
        /**
         * Public Certificate byte array
         */
        blob?: string;
        /**
         * Public Certificate Location
         */
        publicCertificateLocation?: string;
        /**
         * Certificate Thumbprint
         */
        thumbprint: string;
    }

    /**
     * Push settings for the App.
     */
    export interface PushSettingsResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * PushSettings resource specific properties
         */
        properties?: outputs.web.PushSettingsResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * PushSettings resource specific properties
     */
    export interface PushSettingsResponseProperties {
        /**
         * Gets or sets a JSON string containing a list of dynamic tags that will be evaluated from user claims in the push registration endpoint.
         */
        dynamicTagsJson?: string;
        /**
         * Gets or sets a flag indicating whether the Push endpoint is enabled.
         */
        isPushEnabled: boolean;
        /**
         * Gets or sets a JSON string containing a list of tags that are whitelisted for use by the push registration endpoint.
         */
        tagWhitelistJson?: string;
        /**
         * Gets or sets a JSON string containing a list of tags that require user authentication to be used in the push registration endpoint.
         * Tags can consist of alphanumeric characters and the following:
         * '_', '@', '#', '.', ':', '-'. 
         * Validation should be performed at the PushRequestHandler.
         */
        tagsRequiringAuth?: string;
    }

    /**
     * Routing rules for ramp up testing. This rule allows to redirect static traffic % to a slot or to gradually change routing % based on performance.
     */
    export interface RampUpRuleResponse {
        /**
         * Hostname of a slot to which the traffic will be redirected if decided to. E.g. myapp-stage.azurewebsites.net.
         */
        actionHostName?: string;
        /**
         * Custom decision algorithm can be provided in TiPCallback site extension which URL can be specified. See TiPCallback site extension for the scaffold and contracts.
         * https://www.siteextensions.net/packages/TiPCallback/
         */
        changeDecisionCallbackUrl?: string;
        /**
         * Specifies interval in minutes to reevaluate ReroutePercentage.
         */
        changeIntervalInMinutes?: number;
        /**
         * In auto ramp up scenario this is the step to add/remove from <code>ReroutePercentage</code> until it reaches \n<code>MinReroutePercentage</code> or 
         * <code>MaxReroutePercentage</code>. Site metrics are checked every N minutes specified in <code>ChangeIntervalInMinutes</code>.\nCustom decision algorithm 
         * can be provided in TiPCallback site extension which URL can be specified in <code>ChangeDecisionCallbackUrl</code>.
         */
        changeStep?: number;
        /**
         * Specifies upper boundary below which ReroutePercentage will stay.
         */
        maxReroutePercentage?: number;
        /**
         * Specifies lower boundary above which ReroutePercentage will stay.
         */
        minReroutePercentage?: number;
        /**
         * Name of the routing rule. The recommended name would be to point to the slot which will receive the traffic in the experiment.
         */
        name?: string;
        /**
         * Percentage of the traffic which will be redirected to <code>ActionHostName</code>.
         */
        reroutePercentage?: number;
    }

    /**
     * RelayServiceConnectionEntity resource specific properties
     */
    export interface RelayServiceConnectionEntityResponseProperties {
        biztalkUri?: string;
        entityConnectionString?: string;
        entityName?: string;
        hostname?: string;
        port?: number;
        resourceConnectionString?: string;
        resourceType?: string;
    }

    /**
     * A remote private endpoint connection
     */
    export interface RemotePrivateEndpointConnectionResponse {
        /**
         * PrivateEndpoint of a remote private endpoint connection
         */
        privateEndpoint?: outputs.web.ArmIdWrapperResponse;
        /**
         * The state of a private link connection
         */
        privateLinkServiceConnectionState?: outputs.web.PrivateLinkConnectionStateResponse;
        provisioningState: string;
    }

    /**
     * Trigger based on total requests.
     */
    export interface RequestsBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
    }

    /**
     * Configuration of an App Service app.
     */
    export interface SiteConfigResponse {
        /**
         * <code>true</code> if Always On is enabled; otherwise, <code>false</code>.
         */
        alwaysOn?: boolean;
        /**
         * Information about the formal API definition for the app.
         */
        apiDefinition?: outputs.web.ApiDefinitionInfoResponse;
        /**
         * Azure API management settings linked to the app.
         */
        apiManagementConfig?: outputs.web.ApiManagementConfigResponse;
        /**
         * App command line to launch.
         */
        appCommandLine?: string;
        /**
         * Application settings.
         */
        appSettings?: outputs.web.NameValuePairResponse[];
        /**
         * <code>true</code> if Auto Heal is enabled; otherwise, <code>false</code>.
         */
        autoHealEnabled?: boolean;
        /**
         * Auto Heal rules.
         */
        autoHealRules?: outputs.web.AutoHealRulesResponse;
        /**
         * Auto-swap slot name.
         */
        autoSwapSlotName?: string;
        /**
         * Connection strings.
         */
        connectionStrings?: outputs.web.ConnStringInfoResponse[];
        /**
         * Cross-Origin Resource Sharing (CORS) settings.
         */
        cors?: outputs.web.CorsSettingsResponse;
        /**
         * Default documents.
         */
        defaultDocuments?: string[];
        /**
         * <code>true</code> if detailed error logging is enabled; otherwise, <code>false</code>.
         */
        detailedErrorLoggingEnabled?: boolean;
        /**
         * Document root.
         */
        documentRoot?: string;
        /**
         * This is work around for polymorphic types.
         */
        experiments?: outputs.web.ExperimentsResponse;
        /**
         * State of FTP / FTPS service
         */
        ftpsState?: string;
        /**
         * Handler mappings.
         */
        handlerMappings?: outputs.web.HandlerMappingResponse[];
        /**
         * Health check path
         */
        healthCheckPath?: string;
        /**
         * Http20Enabled: configures a web site to allow clients to connect over http2.0
         */
        http20Enabled?: boolean;
        /**
         * <code>true</code> if HTTP logging is enabled; otherwise, <code>false</code>.
         */
        httpLoggingEnabled?: boolean;
        /**
         * IP security restrictions for main.
         */
        ipSecurityRestrictions?: outputs.web.IpSecurityRestrictionResponse[];
        /**
         * Java container.
         */
        javaContainer?: string;
        /**
         * Java container version.
         */
        javaContainerVersion?: string;
        /**
         * Java version.
         */
        javaVersion?: string;
        /**
         * Site limits.
         */
        limits?: outputs.web.SiteLimitsResponse;
        /**
         * Linux App Framework and version
         */
        linuxFxVersion?: string;
        /**
         * Site load balancing.
         */
        loadBalancing?: string;
        /**
         * <code>true</code> to enable local MySQL; otherwise, <code>false</code>.
         */
        localMySqlEnabled?: boolean;
        /**
         * HTTP logs directory size limit.
         */
        logsDirectorySizeLimit?: number;
        /**
         * Site MachineKey.
         */
        machineKey: outputs.web.SiteMachineKeyResponse;
        /**
         * Managed pipeline mode.
         */
        managedPipelineMode?: string;
        /**
         * Managed Service Identity Id
         */
        managedServiceIdentityId?: number;
        /**
         * MinTlsVersion: configures the minimum version of TLS required for SSL requests
         */
        minTlsVersion?: string;
        /**
         * .NET Framework version.
         */
        netFrameworkVersion?: string;
        /**
         * Version of Node.js.
         */
        nodeVersion?: string;
        /**
         * Number of workers.
         */
        numberOfWorkers?: number;
        /**
         * Version of PHP.
         */
        phpVersion?: string;
        /**
         * Version of PowerShell.
         */
        powerShellVersion?: string;
        /**
         * Number of preWarmed instances.
         * This setting only applies to the Consumption and Elastic Plans
         */
        preWarmedInstanceCount?: number;
        /**
         * Publishing user name.
         */
        publishingUsername?: string;
        /**
         * Push endpoint settings.
         */
        push?: outputs.web.PushSettingsResponse;
        /**
         * Version of Python.
         */
        pythonVersion?: string;
        /**
         * <code>true</code> if remote debugging is enabled; otherwise, <code>false</code>.
         */
        remoteDebuggingEnabled?: boolean;
        /**
         * Remote debugging version.
         */
        remoteDebuggingVersion?: string;
        /**
         * <code>true</code> if request tracing is enabled; otherwise, <code>false</code>.
         */
        requestTracingEnabled?: boolean;
        /**
         * Request tracing expiration time.
         */
        requestTracingExpirationTime?: string;
        /**
         * IP security restrictions for scm.
         */
        scmIpSecurityRestrictions?: outputs.web.IpSecurityRestrictionResponse[];
        /**
         * IP security restrictions for scm to use main.
         */
        scmIpSecurityRestrictionsUseMain?: boolean;
        /**
         * SCM type.
         */
        scmType?: string;
        /**
         * Tracing options.
         */
        tracingOptions?: string;
        /**
         * <code>true</code> to use 32-bit worker process; otherwise, <code>false</code>.
         */
        use32BitWorkerProcess?: boolean;
        /**
         * Virtual applications.
         */
        virtualApplications?: outputs.web.VirtualApplicationResponse[];
        /**
         * Virtual Network name.
         */
        vnetName?: string;
        /**
         * <code>true</code> if WebSocket is enabled; otherwise, <code>false</code>.
         */
        webSocketsEnabled?: boolean;
        /**
         * Xenon App Framework and version
         */
        windowsFxVersion?: string;
        /**
         * Explicit Managed Service Identity Id
         */
        xManagedServiceIdentityId?: number;
    }

    /**
     * SiteExtensionInfo resource specific properties
     */
    export interface SiteExtensionInfoResponseProperties {
        /**
         * List of authors.
         */
        authors?: string[];
        /**
         * Site Extension comment.
         */
        comment?: string;
        /**
         * Detailed description.
         */
        description?: string;
        /**
         * Count of downloads.
         */
        download_count?: number;
        /**
         * Site extension ID.
         */
        extension_id?: string;
        /**
         * Site extension type.
         */
        extension_type?: string;
        /**
         * Extension URL.
         */
        extension_url?: string;
        /**
         * Feed URL.
         */
        feed_url?: string;
        /**
         * Icon URL.
         */
        icon_url?: string;
        /**
         * Installed timestamp.
         */
        installed_date_time?: string;
        /**
         * Installer command line parameters.
         */
        installer_command_line_params?: string;
        /**
         * License URL.
         */
        license_url?: string;
        /**
         * <code>true</code> if the local version is the latest version; <code>false</code> otherwise.
         */
        local_is_latest_version?: boolean;
        /**
         * Local path.
         */
        local_path?: string;
        /**
         * Project URL.
         */
        project_url?: string;
        /**
         * Provisioning state.
         */
        provisioningState?: string;
        /**
         * Published timestamp.
         */
        published_date_time?: string;
        /**
         * Summary description.
         */
        summary?: string;
        title?: string;
        /**
         * Version information.
         */
        version?: string;
    }

    /**
     * Metric limits set on an app.
     */
    export interface SiteLimitsResponse {
        /**
         * Maximum allowed disk size usage in MB.
         */
        maxDiskSizeInMb?: number;
        /**
         * Maximum allowed memory usage in MB.
         */
        maxMemoryInMb?: number;
        /**
         * Maximum allowed CPU usage percentage.
         */
        maxPercentageCpu?: number;
    }

    /**
     * MachineKey of an app.
     */
    export interface SiteMachineKeyResponse {
        /**
         * Algorithm used for decryption.
         */
        decryption?: string;
        /**
         * Decryption key.
         */
        decryptionKey?: string;
        /**
         * MachineKey validation.
         */
        validation?: string;
        /**
         * Validation key.
         */
        validationKey?: string;
    }

    /**
     * Site resource specific properties
     */
    export interface SiteResponseProperties {
        /**
         * Management information availability state for the app.
         */
        availabilityState: string;
        /**
         * <code>true</code> to enable client affinity; <code>false</code> to stop sending session affinity cookies, which route client requests in the same session to the same instance. Default is <code>true</code>.
         */
        clientAffinityEnabled?: boolean;
        /**
         * <code>true</code> to enable client certificate authentication (TLS mutual authentication); otherwise, <code>false</code>. Default is <code>false</code>.
         */
        clientCertEnabled?: boolean;
        /**
         * client certificate authentication comma-separated exclusion paths
         */
        clientCertExclusionPaths?: string;
        /**
         * If specified during app creation, the app is cloned from a source app.
         */
        cloningInfo?: outputs.web.CloningInfoResponse;
        /**
         * Size of the function container.
         */
        containerSize?: number;
        /**
         * Maximum allowed daily memory-time quota (applicable on dynamic apps only).
         */
        dailyMemoryTimeQuota?: number;
        /**
         * Default hostname of the app. Read-only.
         */
        defaultHostName: string;
        /**
         * <code>true</code> if the app is enabled; otherwise, <code>false</code>. Setting this value to false disables the app (takes the app offline).
         */
        enabled?: boolean;
        /**
         * Enabled hostnames for the app.Hostnames need to be assigned (see HostNames) AND enabled. Otherwise,
         * the app is not served on those hostnames.
         */
        enabledHostNames: string[];
        /**
         * Hostname SSL states are used to manage the SSL bindings for app's hostnames.
         */
        hostNameSslStates?: outputs.web.HostNameSslStateResponse[];
        /**
         * Hostnames associated with the app.
         */
        hostNames: string[];
        /**
         * <code>true</code> to disable the public hostnames of the app; otherwise, <code>false</code>.
         *  If <code>true</code>, the app is only accessible via API management process.
         */
        hostNamesDisabled?: boolean;
        /**
         * App Service Environment to use for the app.
         */
        hostingEnvironmentProfile?: outputs.web.HostingEnvironmentProfileResponse;
        /**
         * HttpsOnly: configures a web site to accept only https requests. Issues redirect for
         * http requests
         */
        httpsOnly?: boolean;
        /**
         * Hyper-V sandbox.
         */
        hyperV?: boolean;
        /**
         * Specifies an operation id if this site has a pending operation.
         */
        inProgressOperationId: string;
        /**
         * <code>true</code> if the app is a default container; otherwise, <code>false</code>.
         */
        isDefaultContainer: boolean;
        /**
         * Obsolete: Hyper-V sandbox.
         */
        isXenon?: boolean;
        /**
         * Last time the app was modified, in UTC. Read-only.
         */
        lastModifiedTimeUtc: string;
        /**
         * Maximum number of workers.
         * This only applies to Functions container.
         */
        maxNumberOfWorkers: number;
        /**
         * List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from tenants that site can be hosted with current settings. Read-only.
         */
        outboundIpAddresses: string;
        /**
         * List of IP addresses that the app uses for outbound connections (e.g. database access). Includes VIPs from all tenants except dataComponent. Read-only.
         */
        possibleOutboundIpAddresses: string;
        /**
         * Site redundancy mode
         */
        redundancyMode?: string;
        /**
         * Name of the repository site.
         */
        repositorySiteName: string;
        /**
         * <code>true</code> if reserved; otherwise, <code>false</code>.
         */
        reserved?: boolean;
        /**
         * Name of the resource group the app belongs to. Read-only.
         */
        resourceGroup: string;
        /**
         * <code>true</code> to stop SCM (KUDU) site when the app is stopped; otherwise, <code>false</code>. The default is <code>false</code>.
         */
        scmSiteAlsoStopped?: boolean;
        /**
         * Resource ID of the associated App Service plan, formatted as: "/subscriptions/{subscriptionID}/resourceGroups/{groupName}/providers/Microsoft.Web/serverfarms/{appServicePlanName}".
         */
        serverFarmId?: string;
        /**
         * Configuration of the app.
         */
        siteConfig?: outputs.web.SiteConfigResponse;
        /**
         * Status of the last deployment slot swap operation.
         */
        slotSwapStatus: outputs.web.SlotSwapStatusResponse;
        /**
         * Current state of the app.
         */
        state: string;
        /**
         * App suspended till in case memory-time quota is exceeded.
         */
        suspendedTill: string;
        /**
         * Specifies which deployment slot this app will swap into. Read-only.
         */
        targetSwapSlot: string;
        /**
         * Azure Traffic Manager hostnames associated with the app. Read-only.
         */
        trafficManagerHostNames: string[];
        /**
         * State indicating whether the app has exceeded its quota usage. Read-only.
         */
        usageState: string;
    }

    /**
     * SiteSourceControl resource specific properties
     */
    export interface SiteSourceControlResponseProperties {
        /**
         * Name of branch to use for deployment.
         */
        branch?: string;
        /**
         * <code>true</code> to enable deployment rollback; otherwise, <code>false</code>.
         */
        deploymentRollbackEnabled?: boolean;
        /**
         * <code>true</code> to limit to manual integration; <code>false</code> to enable continuous integration (which configures webhooks into online repos like GitHub).
         */
        isManualIntegration?: boolean;
        /**
         * <code>true</code> for a Mercurial repository; <code>false</code> for a Git repository.
         */
        isMercurial?: boolean;
        /**
         * Repository or source control URL.
         */
        repoUrl?: string;
    }

    /**
     * Description of the App Service plan scale options.
     */
    export interface SkuCapacityResponse {
        /**
         * Default number of workers for this App Service plan SKU.
         */
        default?: number;
        /**
         * Maximum number of workers for this App Service plan SKU.
         */
        maximum?: number;
        /**
         * Minimum number of workers for this App Service plan SKU.
         */
        minimum?: number;
        /**
         * Available scale configurations for an App Service plan.
         */
        scaleType?: string;
    }

    /**
     * Description of a SKU for a scalable resource.
     */
    export interface SkuDescriptionResponse {
        /**
         * Capabilities of the SKU, e.g., is traffic manager enabled?
         */
        capabilities?: outputs.web.CapabilityResponse[];
        /**
         * Current number of instances assigned to the resource.
         */
        capacity?: number;
        /**
         * Family code of the resource SKU.
         */
        family?: string;
        /**
         * Locations of the SKU.
         */
        locations?: string[];
        /**
         * Name of the resource SKU.
         */
        name?: string;
        /**
         * Size specifier of the resource SKU.
         */
        size?: string;
        /**
         * Min, max, and default scale values of the SKU.
         */
        skuCapacity?: outputs.web.SkuCapacityResponse;
        /**
         * Service tier of the resource SKU.
         */
        tier?: string;
    }

    /**
     * The status of the last successful slot swap operation.
     */
    export interface SlotSwapStatusResponse {
        /**
         * The destination slot of the last swap operation.
         */
        destinationSlotName: string;
        /**
         * The source slot of the last swap operation.
         */
        sourceSlotName: string;
        /**
         * The time the last successful slot swap completed.
         */
        timestampUtc: string;
    }

    /**
     * Trigger based on request execution time.
     */
    export interface SlowRequestsBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
        /**
         * Time taken.
         */
        timeTaken?: string;
    }

    /**
     * Build properties for the static site.
     */
    export interface StaticSiteBuildPropertiesResponse {
        /**
         * The path to the api code within the repository.
         */
        apiLocation?: string;
        /**
         * The path of the app artifacts after building.
         */
        appArtifactLocation?: string;
        /**
         * The path to the app code within the repository.
         */
        appLocation?: string;
    }

    /**
     * A static site.
     */
    export interface StaticSiteResponse {
        /**
         * The target branch in the repository.
         */
        branch?: string;
        /**
         * Build properties to configure on the repository.
         */
        buildProperties?: outputs.web.StaticSiteBuildPropertiesResponse;
        /**
         * The custom domains associated with this static site.
         */
        customDomains: string[];
        /**
         * The default autogenerated hostname for the static site.
         */
        defaultHostname: string;
        /**
         * A user's github repository token. This is used to setup the Github Actions workflow file and API secrets.
         */
        repositoryToken?: string;
        /**
         * URL for the repository of the static site.
         */
        repositoryUrl?: string;
    }

    /**
     * Trigger based on status code.
     */
    export interface StatusCodesBasedTriggerResponse {
        /**
         * Request Count.
         */
        count?: number;
        /**
         * HTTP status code.
         */
        status?: number;
        /**
         * Request Sub Status.
         */
        subStatus?: number;
        /**
         * Time interval.
         */
        timeInterval?: string;
        /**
         * Win32 error code.
         */
        win32Status?: number;
    }

    /**
     * SwiftVirtualNetwork resource specific properties
     */
    export interface SwiftVirtualNetworkResponseProperties {
        /**
         * The Virtual Network subnet's resource ID. This is the subnet that this Web App will join. This subnet must have a delegation to Microsoft.Web/serverFarms defined first.
         */
        subnetResourceId?: string;
        /**
         * A flag that specifies if the scale unit this Web App is on supports Swift integration.
         */
        swiftSupported?: boolean;
    }

    /**
     * Virtual application in an app.
     */
    export interface VirtualApplicationResponse {
        /**
         * Physical path.
         */
        physicalPath?: string;
        /**
         * <code>true</code> if preloading is enabled; otherwise, <code>false</code>.
         */
        preloadEnabled?: boolean;
        /**
         * Virtual directories for virtual application.
         */
        virtualDirectories?: outputs.web.VirtualDirectoryResponse[];
        /**
         * Virtual path.
         */
        virtualPath?: string;
    }

    /**
     * Directory for virtual application.
     */
    export interface VirtualDirectoryResponse {
        /**
         * Physical path.
         */
        physicalPath?: string;
        /**
         * Path to virtual application.
         */
        virtualPath?: string;
    }

    /**
     * VnetInfo resource specific properties
     */
    export interface VnetInfoResponseProperties {
        /**
         * A certificate file (.cer) blob containing the public key of the private key used to authenticate a 
         * Point-To-Site VPN connection.
         */
        certBlob?: string;
        /**
         * The client certificate thumbprint.
         */
        certThumbprint: string;
        /**
         * DNS servers to be used by this Virtual Network. This should be a comma-separated list of IP addresses.
         */
        dnsServers?: string;
        /**
         * Flag that is used to denote if this is VNET injection
         */
        isSwift?: boolean;
        /**
         * <code>true</code> if a resync is required; otherwise, <code>false</code>.
         */
        resyncRequired: boolean;
        /**
         * The routes that this Virtual Network connection uses.
         */
        routes: outputs.web.VnetRouteResponse[];
        /**
         * The Virtual Network's resource ID.
         */
        vnetResourceId?: string;
    }

    /**
     * Virtual Network route contract used to pass routing information for a Virtual Network.
     */
    export interface VnetRouteResponse {
        /**
         * Resource Id.
         */
        id: string;
        /**
         * Kind of resource.
         */
        kind?: string;
        /**
         * Resource Name.
         */
        name: string;
        /**
         * VnetRoute resource specific properties
         */
        properties?: outputs.web.VnetRouteResponseProperties;
        /**
         * Resource type.
         */
        type: string;
    }

    /**
     * VnetRoute resource specific properties
     */
    export interface VnetRouteResponseProperties {
        /**
         * The ending address for this route. If the start address is specified in CIDR notation, this must be omitted.
         */
        endAddress?: string;
        /**
         * The type of route this is:
         * DEFAULT - By default, every app has routes to the local address ranges specified by RFC1918
         * INHERITED - Routes inherited from the real Virtual Network routes
         * STATIC - Static route set on the app only
         *
         * These values will be used for syncing an app's routes with those from a Virtual Network.
         */
        routeType?: string;
        /**
         * The starting address for this route. This may also include a CIDR notation, in which case the end address must not be specified.
         */
        startAddress?: string;
    }
}

